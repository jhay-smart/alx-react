{"version":3,"file":"findCurrentFiberUsingSlowPath.js","names":["HostRoot","Placement","Hydrating","NoFlags","getNearestMountedFiber","fiber","node","nearestMounted","alternate","nextNode","flags","tag","findCurrentFiberUsingSlowPath","Error","a","b","parentA","parentB","nextParent","child","sibling","didFindChild","stateNode","current","module","exports"],"sources":["../src/findCurrentFiberUsingSlowPath.js"],"sourcesContent":["// Extracted from https://github.com/facebook/react/blob/a724a3b578dce77d427bef313102a4d0e978d9b4/packages/react-reconciler/src/ReactFiberTreeReflection.js\n\nconst HostRoot = 3;\n\nconst Placement = 0b0000000000000000000000010;\nconst Hydrating = 0b0000000000001000000000000;\nconst NoFlags = 0b0000000000000000000000000;\n\nfunction getNearestMountedFiber(fiber) {\n  let node = fiber;\n  let nearestMounted = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    let nextNode = node;\n    do {\n      node = nextNode;\n      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n        // This is an insertion or in-progress hydration. The nearest possible\n        // mounted fiber is the parent but we need to continue to figure out\n        // if that one is still mounted.\n        nearestMounted = node.return;\n      }\n      nextNode = node.return;\n    } while (nextNode);\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return nearestMounted;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return null;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  const alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    const nearestMounted = getNearestMountedFiber(fiber);\n\n    if (nearestMounted === null) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (nearestMounted !== fiber) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  let a = fiber;\n  let b = alternate;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const parentA = a.return;\n    if (parentA === null) {\n      // We're at the root.\n      break;\n    }\n    const parentB = parentA.alternate;\n    if (parentB === null) {\n      // There is no alternate. This is an unusual case. Currently, it only\n      // happens when a Suspense component is hidden. An extra fragment fiber\n      // is inserted in between the Suspense fiber and its children. Skip\n      // over this extra fragment fiber and proceed to the next parent.\n      const nextParent = parentA.return;\n      if (nextParent !== null) {\n        a = b = nextParent;\n        continue;\n      }\n      // If there's no parent, we're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      let child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          return alternate;\n        }\n        child = child.sibling;\n      }\n\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      let didFindChild = false;\n      let child = parentA.child;\n      while (child) {\n        if (child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child = child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        child = parentB.child;\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child = child.sibling;\n        }\n\n        if (!didFindChild) {\n          throw new Error(\n            'Child was not found in either parent set. This indicates a bug ' +\n              'in React related to the return pointer. Please file an issue.',\n          );\n        }\n      }\n    }\n\n    if (a.alternate !== b) {\n      throw new Error(\n        \"Return fibers should always be each others' alternates. \" +\n          'This error is likely caused by a bug in React. Please file an issue.',\n      );\n    }\n  }\n\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  if (a.tag !== HostRoot) {\n    throw new Error('Unable to find node on an unmounted component.');\n  }\n\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nmodule.exports = findCurrentFiberUsingSlowPath;\n"],"mappings":";;AAAA;AAEA,IAAMA,QAAQ,GAAG,CAAjB;AAEA,IAAMC,SAAS,GAAG,CAAlB;AACA,IAAMC,SAAS,GAAG,IAAlB;AACA,IAAMC,OAAO,GAAG,CAAhB;;AAEA,SAASC,sBAAT,CAAgCC,KAAhC,EAAuC;EACrC,IAAIC,IAAI,GAAGD,KAAX;EACA,IAAIE,cAAc,GAAGF,KAArB;;EACA,IAAI,CAACA,KAAK,CAACG,SAAX,EAAsB;IACpB;IACA;IACA,IAAIC,QAAQ,GAAGH,IAAf;;IACA,GAAG;MACDA,IAAI,GAAGG,QAAP;;MACA,IAAI,CAACH,IAAI,CAACI,KAAL,IAAcT,SAAS,GAAGC,SAA1B,CAAD,MAA2CC,OAA/C,EAAwD;QACtD;QACA;QACA;QACAI,cAAc,GAAGD,IAAI,UAArB;MACD;;MACDG,QAAQ,GAAGH,IAAI,UAAf;IACD,CATD,QASSG,QATT;EAUD,CAdD,MAcO;IACL,OAAOH,IAAI,UAAX,EAAoB;MAClBA,IAAI,GAAGA,IAAI,UAAX;IACD;EACF;;EACD,IAAIA,IAAI,CAACK,GAAL,KAAaX,QAAjB,EAA2B;IACzB;IACA;IACA,OAAOO,cAAP;EACD,CA1BoC,CA2BrC;EACA;;;EACA,OAAO,IAAP;AACD;;AAED,SAASK,6BAAT,CAAuCP,KAAvC,EAA8C;EAC5C,IAAMG,SAAS,GAAGH,KAAK,CAACG,SAAxB;;EACA,IAAI,CAACA,SAAL,EAAgB;IACd;IACA,IAAMD,cAAc,GAAGH,sBAAsB,CAACC,KAAD,CAA7C;;IAEA,IAAIE,cAAc,KAAK,IAAvB,EAA6B;MAC3B,MAAM,IAAIM,KAAJ,CAAU,gDAAV,CAAN;IACD;;IAED,IAAIN,cAAc,KAAKF,KAAvB,EAA8B;MAC5B,OAAO,IAAP;IACD;;IACD,OAAOA,KAAP;EACD,CAd2C,CAe5C;EACA;EACA;;;EACA,IAAIS,CAAC,GAAGT,KAAR;EACA,IAAIU,CAAC,GAAGP,SAAR,CAnB4C,CAoB5C;;EACA,OAAO,IAAP,EAAa;IACX,IAAMQ,OAAO,GAAGF,CAAC,UAAjB;;IACA,IAAIE,OAAO,KAAK,IAAhB,EAAsB;MACpB;MACA;IACD;;IACD,IAAMC,OAAO,GAAGD,OAAO,CAACR,SAAxB;;IACA,IAAIS,OAAO,KAAK,IAAhB,EAAsB;MACpB;MACA;MACA;MACA;MACA,IAAMC,UAAU,GAAGF,OAAO,UAA1B;;MACA,IAAIE,UAAU,KAAK,IAAnB,EAAyB;QACvBJ,CAAC,GAAGC,CAAC,GAAGG,UAAR;QACA;MACD,CATmB,CAUpB;;;MACA;IACD,CAnBU,CAqBX;IACA;IACA;;;IACA,IAAIF,OAAO,CAACG,KAAR,KAAkBF,OAAO,CAACE,KAA9B,EAAqC;MACnC,IAAIA,KAAK,GAAGH,OAAO,CAACG,KAApB;;MACA,OAAOA,KAAP,EAAc;QACZ,IAAIA,KAAK,KAAKL,CAAd,EAAiB;UACf;UACA,OAAOT,KAAP;QACD;;QACD,IAAIc,KAAK,KAAKJ,CAAd,EAAiB;UACf;UACA,OAAOP,SAAP;QACD;;QACDW,KAAK,GAAGA,KAAK,CAACC,OAAd;MACD,CAZkC,CAcnC;MACA;;;MACA,MAAM,IAAIP,KAAJ,CAAU,gDAAV,CAAN;IACD;;IAED,IAAIC,CAAC,UAAD,KAAaC,CAAC,UAAlB,EAA2B;MACzB;MACA;MACA;MACA;MACAD,CAAC,GAAGE,OAAJ;MACAD,CAAC,GAAGE,OAAJ;IACD,CAPD,MAOO;MACL;MACA;MACA;MACA;MACA;MACA,IAAII,YAAY,GAAG,KAAnB;MACA,IAAIF,MAAK,GAAGH,OAAO,CAACG,KAApB;;MACA,OAAOA,MAAP,EAAc;QACZ,IAAIA,MAAK,KAAKL,CAAd,EAAiB;UACfO,YAAY,GAAG,IAAf;UACAP,CAAC,GAAGE,OAAJ;UACAD,CAAC,GAAGE,OAAJ;UACA;QACD;;QACD,IAAIE,MAAK,KAAKJ,CAAd,EAAiB;UACfM,YAAY,GAAG,IAAf;UACAN,CAAC,GAAGC,OAAJ;UACAF,CAAC,GAAGG,OAAJ;UACA;QACD;;QACDE,MAAK,GAAGA,MAAK,CAACC,OAAd;MACD;;MACD,IAAI,CAACC,YAAL,EAAmB;QACjB;QACAF,MAAK,GAAGF,OAAO,CAACE,KAAhB;;QACA,OAAOA,MAAP,EAAc;UACZ,IAAIA,MAAK,KAAKL,CAAd,EAAiB;YACfO,YAAY,GAAG,IAAf;YACAP,CAAC,GAAGG,OAAJ;YACAF,CAAC,GAAGC,OAAJ;YACA;UACD;;UACD,IAAIG,MAAK,KAAKJ,CAAd,EAAiB;YACfM,YAAY,GAAG,IAAf;YACAN,CAAC,GAAGE,OAAJ;YACAH,CAAC,GAAGE,OAAJ;YACA;UACD;;UACDG,MAAK,GAAGA,MAAK,CAACC,OAAd;QACD;;QAED,IAAI,CAACC,YAAL,EAAmB;UACjB,MAAM,IAAIR,KAAJ,CACJ,oEACE,+DAFE,CAAN;QAID;MACF;IACF;;IAED,IAAIC,CAAC,CAACN,SAAF,KAAgBO,CAApB,EAAuB;MACrB,MAAM,IAAIF,KAAJ,CACJ,6DACE,sEAFE,CAAN;IAID;EACF,CAhI2C,CAkI5C;EACA;;;EACA,IAAIC,CAAC,CAACH,GAAF,KAAUX,QAAd,EAAwB;IACtB,MAAM,IAAIa,KAAJ,CAAU,gDAAV,CAAN;EACD;;EAED,IAAIC,CAAC,CAACQ,SAAF,CAAYC,OAAZ,KAAwBT,CAA5B,EAA+B;IAC7B;IACA,OAAOT,KAAP;EACD,CA3I2C,CA4I5C;;;EACA,OAAOG,SAAP;AACD;;AAEDgB,MAAM,CAACC,OAAP,GAAiBb,6BAAjB"}