"use strict";

var _react = _interopRequireDefault(require("react"));

var _reactDom = require("react-dom");

var _client = require("react-dom/client");

var _server = _interopRequireDefault(require("react-dom/server"));

var _shallow = _interopRequireDefault(require("react-test-renderer/shallow"));

var _testUtils = _interopRequireDefault(require("react-dom/test-utils"));

var _checkPropTypes2 = _interopRequireDefault(require("prop-types/checkPropTypes"));

var _has = _interopRequireDefault(require("has"));

var _reactIs = require("react-is");

var _enzyme = require("enzyme");

var _Utils = require("enzyme/build/Utils");

var _enzymeShallowEqual = _interopRequireDefault(require("enzyme-shallow-equal"));

var _enzymeAdapterUtils = require("@chalbert/enzyme-adapter-utils");

var _findCurrentFiberUsingSlowPath = _interopRequireDefault(require("./findCurrentFiberUsingSlowPath"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Lazily populated if DOM is available.
function nodeAndSiblingsArray(nodeWithSibling) {
  var array = [];
  var node = nodeWithSibling;

  while (node != null) {
    array.push(node);
    node = node.sibling;
  }

  return array;
}

function flatten(arr) {
  var result = [];
  var stack = [{
    i: 0,
    array: arr
  }];

  while (stack.length) {
    var n = stack.pop();

    while (n.i < n.array.length) {
      var el = n.array[n.i];
      n.i += 1;

      if (Array.isArray(el)) {
        stack.push(n);
        stack.push({
          i: 0,
          array: el
        });
        break;
      }

      result.push(el);
    }
  }

  return result;
}

function nodeTypeFromType(type) {
  if (type === _reactIs.Portal) {
    return 'portal';
  }

  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);
}

function isMemo(type) {
  return (0, _enzymeAdapterUtils.compareNodeTypeOf)(type, _reactIs.Memo);
}

function isLazy(type) {
  return (0, _enzymeAdapterUtils.compareNodeTypeOf)(type, _reactIs.Lazy);
}

function unmemoType(type) {
  return isMemo(type) ? type.type : type;
}

function checkIsSuspenseAndCloneElement(el, _ref) {
  var suspenseFallback = _ref.suspenseFallback;

  if (!(0, _reactIs.isSuspense)(el)) {
    return el;
  }

  var children = el.props.children;

  if (suspenseFallback) {
    var fallback = el.props.fallback;
    children = replaceLazyWithFallback(children, fallback);
  }

  var FakeSuspenseWrapper = function FakeSuspenseWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(el.type, _objectSpread(_objectSpread({}, el.props), props), children);
  };

  return /*#__PURE__*/_react["default"].createElement(FakeSuspenseWrapper, null, children);
}

function elementToTree(el) {
  if (!(0, _reactIs.isPortal)(el)) {
    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);
  }

  var children = el.children,
      containerInfo = el.containerInfo;
  var props = {
    children: children,
    containerInfo: containerInfo
  };
  return {
    nodeType: 'portal',
    type: _reactIs.Portal,
    props: props,
    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),
    ref: el.ref || null,
    instance: null,
    rendered: elementToTree(el.children)
  };
}

function _toTree(vnode) {
  if (vnode == null) {
    return null;
  } // TODO(lmr): I'm not really sure I understand whether or not this is what
  // i should be doing, or if this is a hack for something i'm doing wrong
  // somewhere else. Should talk to sebastian about this perhaps


  var node = (0, _findCurrentFiberUsingSlowPath["default"])(vnode);

  switch (node.tag) {
    case _enzymeAdapterUtils.TAG_CODES.HostRoot:
      return childrenToTree(node.child);

    case _enzymeAdapterUtils.TAG_CODES.HostPortal:
      {
        var containerInfo = node.stateNode.containerInfo,
            children = node.memoizedProps;
        var props = {
          containerInfo: containerInfo,
          children: children
        };
        return {
          nodeType: 'portal',
          type: _reactIs.Portal,
          props: props,
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case _enzymeAdapterUtils.TAG_CODES.IndeterminateComponent:
      return {
        nodeType: 'indeterminate',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };

    case _enzymeAdapterUtils.TAG_CODES.IncompleteClassComponent:
    case _enzymeAdapterUtils.TAG_CODES.ClassComponent:
      return {
        nodeType: 'class',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };

    case _enzymeAdapterUtils.TAG_CODES.FunctionComponent:
      return {
        nodeType: 'function',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: null,
        rendered: childrenToTree(node.child)
      };

    case _enzymeAdapterUtils.TAG_CODES.MemoClass:
      return {
        nodeType: 'class',
        type: node.elementType.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child.child)
      };

    case _enzymeAdapterUtils.TAG_CODES.MemoSFC:
      {
        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));

        if (renderedNodes.length === 0) {
          renderedNodes = [node.memoizedProps.children];
        }

        return {
          nodeType: 'function',
          type: node.elementType,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: renderedNodes
        };
      }

    case _enzymeAdapterUtils.TAG_CODES.HostComponent:
      {
        var _renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));

        if (_renderedNodes.length === 0) {
          _renderedNodes = [node.memoizedProps.children];
        }

        return {
          nodeType: 'host',
          type: node.type,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: node.stateNode,
          rendered: _renderedNodes
        };
      }

    case _enzymeAdapterUtils.TAG_CODES.HostText:
      return node.memoizedProps;

    case _enzymeAdapterUtils.TAG_CODES.DehydratedFragment:
    case _enzymeAdapterUtils.TAG_CODES.Fragment:
    case _enzymeAdapterUtils.TAG_CODES.Mode:
    case _enzymeAdapterUtils.TAG_CODES.ContextProvider:
    case _enzymeAdapterUtils.TAG_CODES.ContextConsumer:
      return childrenToTree(node.child);

    case _enzymeAdapterUtils.TAG_CODES.Profiler:
    case _enzymeAdapterUtils.TAG_CODES.MemoComponent:
    case _enzymeAdapterUtils.TAG_CODES.SimpleMemoComponent:
    case _enzymeAdapterUtils.TAG_CODES.ForwardRef:
      {
        return {
          nodeType: 'function',
          type: node.type,
          props: _objectSpread({}, node.pendingProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case _enzymeAdapterUtils.TAG_CODES.SuspenseListComponent:
    case _enzymeAdapterUtils.TAG_CODES.SuspenseComponent:
      {
        var _children = flatten(nodeAndSiblingsArray(node.child.child).map(_toTree));

        return {
          nodeType: 'function',
          type: _reactIs.Suspense,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: _children.length ? _children : childrenToTree(node.child)
        };
      }

    case _enzymeAdapterUtils.TAG_CODES.LazyComponent:
      return childrenToTree(node.child);

    case _enzymeAdapterUtils.TAG_CODES.ScopeComponent:
    case _enzymeAdapterUtils.TAG_CODES.OffscreenComponent:
    case _enzymeAdapterUtils.TAG_CODES.LegacyHiddenComponent:
    case _enzymeAdapterUtils.TAG_CODES.CacheComponent:
    case _enzymeAdapterUtils.TAG_CODES.TracingMarkerComponent:
      return _toTree(node.child);

    default:
      throw new Error("Enzyme Internal Error: unknown node with tag ".concat(node.tag));
  }
}

function childrenToTree(node) {
  if (!node) {
    return null;
  }

  var children = nodeAndSiblingsArray(node);

  if (children.length === 0) {
    return null;
  }

  if (children.length === 1) {
    return _toTree(children[0]);
  }

  return flatten(children.map(_toTree));
}

function _nodeToHostNode(_node) {
  // NOTE(lmr): node could be a function component
  // which wont have an instance prop, but we can get the
  // host node associated with its return value at that point.
  // Although this breaks down if the return value is an array,
  // as is possible with React 16.
  var node = _node;

  while (node && !Array.isArray(node) && node.instance === null) {
    node = node.rendered;
  } // if the SFC returned null effectively, there is no host node.


  if (!node) {
    return null;
  }

  var mapper = function mapper(item) {
    if (item && item.instance) return (0, _reactDom.findDOMNode)(item.instance);
    return null;
  };

  if (Array.isArray(node)) {
    return node.map(mapper);
  }

  if (Array.isArray(node.rendered) && node.nodeType === 'class') {
    return node.rendered.map(mapper);
  }

  return mapper(node);
}

function replaceLazyWithFallback(node, fallback) {
  if (!node) {
    return null;
  }

  if (Array.isArray(node)) {
    return node.map(function (el) {
      return replaceLazyWithFallback(el, fallback);
    });
  }

  if (isLazy(node.type)) {
    // console.log('-----------------replaceLazyWithFallback');
    return fallback;
  }

  return _objectSpread(_objectSpread({}, node), {}, {
    props: _objectSpread(_objectSpread({}, node.props), {}, {
      children: replaceLazyWithFallback(node.props.children, fallback)
    })
  });
}

function getEmptyStateValue() {
  // this handles a bug in React 16.0 - 16.2
  // see https://github.com/facebook/react/commit/39be83565c65f9c522150e52375167568a2a1459
  // also see https://github.com/facebook/react/pull/11965
  var EmptyState = /*#__PURE__*/function (_React$Component) {
    _inherits(EmptyState, _React$Component);

    var _super = _createSuper(EmptyState);

    function EmptyState() {
      _classCallCheck(this, EmptyState);

      return _super.apply(this, arguments);
    }

    _createClass(EmptyState, [{
      key: "render",
      value: function render() {
        return null;
      }
    }]);

    return EmptyState;
  }(_react["default"].Component);

  var testRenderer = new _shallow["default"]();
  testRenderer.render( /*#__PURE__*/_react["default"].createElement(EmptyState));
  return testRenderer._instance.state;
}

function wrapAct(fn) {
  var returnVal;

  _testUtils["default"].act(function () {
    returnVal = fn();
  });

  return returnVal;
}

function getProviderDefaultValue(Provider) {
  // React stores references to the Provider's defaultValue differently across versions.
  if ('_defaultValue' in Provider._context) {
    return Provider._context._defaultValue;
  }

  if ('_currentValue' in Provider._context) {
    return Provider._context._currentValue;
  }

  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');
}

function makeFakeElement(type) {
  return {
    $$typeof: _reactIs.Element,
    type: type
  };
}

function isStateful(Component) {
  return Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs)) // fallback for createClass components
  ;
}

var ReactEighteenAdapter = /*#__PURE__*/function (_EnzymeAdapter) {
  _inherits(ReactEighteenAdapter, _EnzymeAdapter);

  var _super2 = _createSuper(ReactEighteenAdapter);

  function ReactEighteenAdapter() {
    var _this;

    _classCallCheck(this, ReactEighteenAdapter);

    _this = _super2.call(this); // Monkey patching so we don't have to wrap in 'act' each time

    var _ReactWrapper$prototy = _enzyme.ReactWrapper.prototype,
        setProps = _ReactWrapper$prototy.setProps,
        setState = _ReactWrapper$prototy.setState;

    _enzyme.ReactWrapper.prototype.setProps = function () {
      var _this2 = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return wrapAct(function () {
        return setProps.apply(_this2, args);
      });
    };

    _enzyme.ReactWrapper.prototype.setState = function () {
      var _this3 = this;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return wrapAct(function () {
        return setState.apply(_this3, args);
      });
    };

    var lifecycles = _this.options.lifecycles;
    _this.options = _objectSpread(_objectSpread({}, _this.options), {}, {
      enableComponentDidUpdateOnSetState: true,
      // TODO: remove, semver-major
      legacyContextMode: 'parent',
      lifecycles: _objectSpread(_objectSpread({}, lifecycles), {}, {
        componentDidUpdate: {
          onSetState: true
        },
        getDerivedStateFromProps: {
          hasShouldComponentUpdateBug: false
        },
        getSnapshotBeforeUpdate: true,
        setState: {
          skipsComponentDidUpdateOnNullish: true
        },
        getChildContext: {
          calledByRenderer: false
        },
        getDerivedStateFromError: true
      })
    });
    return _this;
  }

  _createClass(ReactEighteenAdapter, [{
    key: "createMountRenderer",
    value: function createMountRenderer(options) {
      (0, _enzymeAdapterUtils.assertDomAvailable)('mount');

      if ((0, _has["default"])(options, 'suspenseFallback')) {
        throw new TypeError('`suspenseFallback` is not supported by the `mount` renderer');
      }

      var attachTo = options.attachTo,
          hydrateIn = options.hydrateIn,
          wrappingComponentProps = options.wrappingComponentProps;
      var domNode = hydrateIn || attachTo || global.document.createElement('div');
      var instance = null;
      var adapter = this;
      var root;
      return {
        render: function render(el, context, callback) {
          return wrapAct(function () {
            if (instance === null) {
              var type = el.type,
                  props = el.props,
                  ref = el.ref;

              var wrapperProps = _objectSpread({
                Component: type,
                props: props,
                wrappingComponentProps: wrappingComponentProps,
                context: context
              }, ref && {
                refProp: ref
              });

              var wrappedEl;
              var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, _objectSpread(_objectSpread({}, options), {}, {
                adapter: adapter
              }));
              wrappedEl = /*#__PURE__*/_react["default"].createElement(ReactWrapperComponent, wrapperProps);
              root = hydrateIn ? (0, _client.hydrateRoot)(domNode, wrappedEl) : (0, _client.createRoot)(domNode);
              (0, _reactDom.flushSync)(function () {
                root.render(wrappedEl);
              });
              instance = (0, _enzymeAdapterUtils.getPublicRootInstance)(root);

              if (typeof callback === 'function') {
                callback();
              }
            } else {
              instance.setChildProps(el.props, context, callback);
            }
          });
        },
        unmount: function unmount() {
          wrapAct(function () {
            var _root;

            (_root = root) === null || _root === void 0 ? void 0 : _root.unmount();
          });
          instance = null;
        },
        getNode: function getNode() {
          if (!instance) {
            return null;
          }

          return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternals), options);
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          var isErrorBoundary = function isErrorBoundary(_ref2) {
            var elInstance = _ref2.instance,
                type = _ref2.type;

            if (type && type.getDerivedStateFromError) {
              return true;
            }

            return elInstance && elInstance.componentDidCatch;
          };

          var _ref3 = nodeHierarchy.find(isErrorBoundary) || {},
              catchingInstance = _ref3.instance,
              catchingType = _ref3.type;

          _testUtils["default"].act(function () {
            (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode, catchingType);
          });
        },
        simulateEvent: function simulateEvent(node, event, mock) {
          var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event);
          var eventFn = _testUtils["default"].Simulate[mappedEvent];

          if (!eventFn) {
            throw new TypeError("ReactWrapper::simulate() event '".concat(event, "' does not exist"));
          }

          wrapAct(function () {
            eventFn(adapter.nodeToHostNode(node), mock);
          });
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn();
        },
        getWrappingComponentRenderer: function getWrappingComponentRenderer() {
          return _objectSpread(_objectSpread({}, this), (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({
            toTree: function toTree(inst) {
              return _toTree(inst._reactInternals);
            },
            getMountWrapperInstance: function getMountWrapperInstance() {
              return instance;
            }
          }));
        },
        wrapInvoke: wrapAct
      };
    }
  }, {
    key: "createShallowRenderer",
    value: function createShallowRenderer() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var adapter = this;
      var renderer = new _shallow["default"]();
      var suspenseFallback = options.suspenseFallback;

      if (typeof suspenseFallback !== 'undefined' && typeof suspenseFallback !== 'boolean') {
        throw TypeError('`options.suspenseFallback` should be boolean or undefined');
      }

      var isDOM = false;
      var cachedNode = null;
      var lastComponent = null;
      var wrappedComponent = null;
      var sentinel = {}; // wrap memo components with a PureComponent, or a class component with sCU

      var wrapPureComponent = function wrapPureComponent(Component, compare) {
        if (lastComponent !== Component) {
          if (isStateful(Component)) {
            wrappedComponent = /*#__PURE__*/function (_Component) {
              _inherits(wrappedComponent, _Component);

              var _super3 = _createSuper(wrappedComponent);

              function wrappedComponent() {
                _classCallCheck(this, wrappedComponent);

                return _super3.apply(this, arguments);
              }

              return _createClass(wrappedComponent);
            }(Component);

            if (compare) {
              wrappedComponent.prototype.shouldComponentUpdate = function (nextProps) {
                return !compare(_this4.props, nextProps);
              };
            } else {
              wrappedComponent.prototype.isPureReactComponent = true;
            }
          } else {
            var memoized = sentinel;
            var prevProps;

            wrappedComponent = function wrappedComponentFn(props) {
              var shouldUpdate = memoized === sentinel || (compare ? !compare(prevProps, props) : !(0, _enzymeShallowEqual["default"])(prevProps, props));

              if (shouldUpdate) {
                for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                  args[_key3 - 1] = arguments[_key3];
                }

                memoized = Component.apply(void 0, [_objectSpread(_objectSpread({}, Component.defaultProps), props)].concat(args));
                prevProps = props;
              }

              return memoized;
            };
          }

          Object.assign(wrappedComponent, Component, {
            displayName: adapter.displayNameOfNode({
              type: Component
            })
          });
          lastComponent = Component;
        }

        return wrappedComponent;
      }; // Wrap functional components on versions prior to 16.5,
      // to avoid inadvertently pass a `this` instance to it.


      var wrapFunctionalComponent = function wrapFunctionalComponent(Component) {
        if ((0, _has["default"])(Component, 'defaultProps')) {
          if (lastComponent !== Component) {
            wrappedComponent = Object.assign(function (props) {
              for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                args[_key4 - 1] = arguments[_key4];
              }

              return Component.apply(void 0, [_objectSpread(_objectSpread({}, Component.defaultProps), props)].concat(args));
            }, Component, {
              displayName: adapter.displayNameOfNode({
                type: Component
              })
            });
            lastComponent = Component;
          }

          return wrappedComponent;
        }

        return Component;
      };

      var renderElement = function renderElement(elConfig) {
        for (var _len5 = arguments.length, rest = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          rest[_key5 - 1] = arguments[_key5];
        }

        // console.log('**************** renderElement');
        var renderedEl = renderer.render.apply(renderer, [elConfig].concat(rest));
        var typeIsExisted = !!(renderedEl && renderedEl.type);

        if (typeIsExisted) {
          var clonedEl = checkIsSuspenseAndCloneElement(renderedEl, {
            suspenseFallback: suspenseFallback
          });
          var elementIsChanged = clonedEl.type !== renderedEl.type;

          if (elementIsChanged) {
            return renderer.render.apply(renderer, [_objectSpread(_objectSpread({}, elConfig), {}, {
              type: clonedEl.type
            })].concat(rest));
          }
        }

        return renderedEl;
      };

      return {
        render: function render(el, unmaskedContext) {
          var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
              _ref4$providerValues = _ref4.providerValues,
              providerValues = _ref4$providerValues === void 0 ? new Map() : _ref4$providerValues;

          cachedNode = el;

          if (typeof el.type === 'string') {
            isDOM = true;
          } else if ((0, _reactIs.isContextProvider)(el)) {
            providerValues.set(el.type, el.props.value);
            var MockProvider = Object.assign(function (props) {
              return props.children;
            }, el.type);
            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderElement(_objectSpread(_objectSpread({}, el), {}, {
                type: MockProvider
              }));
            });
          } else if ((0, _reactIs.isContextConsumer)(el)) {
            var Provider = adapter.getProviderFromConsumer(el.type);
            var value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);
            var MockConsumer = Object.assign(function (props) {
              return props.children(value);
            }, el.type);
            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderElement(_objectSpread(_objectSpread({}, el), {}, {
                type: MockConsumer
              }));
            });
          } else {
            isDOM = false;
            var renderedEl = el;

            if (isLazy(renderedEl)) {
              throw TypeError('`React.lazy` is not supported by shallow rendering.');
            }

            renderedEl = checkIsSuspenseAndCloneElement(renderedEl, {
              suspenseFallback: suspenseFallback
            });
            var _renderedEl = renderedEl,
                Component = _renderedEl.type;
            var context = (0, _enzymeAdapterUtils.getMaskedContext)(Component.contextTypes, unmaskedContext);

            if (isMemo(el.type)) {
              var _el$type = el.type,
                  InnerComp = _el$type.type,
                  compare = _el$type.compare;
              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                return renderElement(_objectSpread(_objectSpread({}, el), {}, {
                  type: wrapPureComponent(InnerComp, compare)
                }), context);
              });
            }

            var isComponentStateful = isStateful(Component);

            if (!isComponentStateful && typeof Component === 'function') {
              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                return renderElement(_objectSpread(_objectSpread({}, renderedEl), {}, {
                  type: wrapFunctionalComponent(Component)
                }), context);
              });
            }

            if (isComponentStateful) {
              if (renderer._instance && el.props === renderer._instance.props && !(0, _enzymeShallowEqual["default"])(context, renderer._instance.context)) {
                var _spyMethod = (0, _enzymeAdapterUtils.spyMethod)(renderer, '_updateClassComponent', function (originalMethod) {
                  return function _updateClassComponent() {
                    var props = renderer._instance.props;

                    var clonedProps = _objectSpread({}, props);

                    renderer._instance.props = clonedProps;

                    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                      args[_key6] = arguments[_key6];
                    }

                    var result = originalMethod.apply(renderer, args);
                    renderer._instance.props = props;
                    restore();
                    return result;
                  };
                }),
                    restore = _spyMethod.restore;
              } // fix react bug; see implementation of `getEmptyStateValue`


              var emptyStateValue = getEmptyStateValue();

              if (emptyStateValue) {
                Object.defineProperty(Component.prototype, 'state', {
                  configurable: true,
                  enumerable: true,
                  get: function get() {
                    return null;
                  },
                  set: function set(value) {
                    if (value !== emptyStateValue) {
                      Object.defineProperty(this, 'state', {
                        configurable: true,
                        enumerable: true,
                        value: value,
                        writable: true
                      });
                    }
                  }
                });
              }
            }

            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderElement(renderedEl, context);
            });
          }
        },
        unmount: function unmount() {
          renderer.unmount();
        },
        getNode: function getNode() {
          if (isDOM) {
            return elementToTree(cachedNode);
          }

          var output = renderer.getRenderOutput();
          return {
            nodeType: nodeTypeFromType(cachedNode.type),
            type: cachedNode.type,
            props: cachedNode.props,
            key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),
            ref: cachedNode.ref,
            instance: renderer._instance,
            rendered: Array.isArray(output) ? flatten(output).map(function (el) {
              return elementToTree(el);
            }) : elementToTree(output)
          };
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode, cachedNode.type);
        },
        simulateEvent: function simulateEvent(node, event) {
          for (var _len7 = arguments.length, args = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {
            args[_key7 - 2] = arguments[_key7];
          }

          var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event)];

          if (handler) {
            (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              // TODO(lmr): create/use synthetic events
              // TODO(lmr): emulate React's event propagation
              handler.apply(void 0, args);
            });
          }
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn();
        },
        checkPropTypes: function checkPropTypes(typeSpecs, values, location, hierarchy) {
          return (0, _checkPropTypes2["default"])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {
            return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));
          });
        }
      };
    }
  }, {
    key: "createStringRenderer",
    value: function createStringRenderer(options) {
      if ((0, _has["default"])(options, 'suspenseFallback')) {
        throw new TypeError('`suspenseFallback` should not be specified in options of string renderer');
      }

      return {
        render: function render(el, context) {
          if (options.context && (el.type.contextTypes || options.childContextTypes)) {
            var childContextTypes = _objectSpread(_objectSpread({}, el.type.contextTypes || {}), options.childContextTypes);

            var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);
            return _server["default"].renderToStaticMarkup( /*#__PURE__*/_react["default"].createElement(ContextWrapper));
          }

          return _server["default"].renderToStaticMarkup(el);
        }
      };
    } // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation
    // specific, like `attach` etc. for React, but not part of this interface explicitly.

  }, {
    key: "createRenderer",
    value: function createRenderer(options) {
      switch (options.mode) {
        case _enzyme.EnzymeAdapter.MODES.MOUNT:
          return this.createMountRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.SHALLOW:
          return this.createShallowRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.STRING:
          return this.createStringRenderer(options);

        default:
          throw new Error("Enzyme Internal Error: Unrecognized mode: ".concat(options.mode));
      }
    }
  }, {
    key: "wrap",
    value: function wrap(element) {
      return (0, _enzymeAdapterUtils.wrap)(element);
    } // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed
    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should
    // be pretty straightforward for people to implement.

  }, {
    key: "nodeToElement",
    value: function nodeToElement(node) {
      if (!node || _typeof(node) !== 'object') return null;
      var type = node.type;
      return /*#__PURE__*/_react["default"].createElement(unmemoType(type), (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));
    }
  }, {
    key: "matchesElementType",
    value: function matchesElementType(node, matchingType) {
      if (!node) {
        return node;
      }

      var type = node.type;
      return unmemoType(type) === unmemoType(matchingType);
    }
  }, {
    key: "elementToNode",
    value: function elementToNode(element) {
      return elementToTree(element);
    }
  }, {
    key: "nodeToHostNode",
    value: function nodeToHostNode(node) {
      var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var nodes = _nodeToHostNode(node);

      if (Array.isArray(nodes) && !supportsArray) {
        // get the first non-null node
        return nodes.filter(Boolean)[0];
      }

      return nodes;
    }
  }, {
    key: "displayNameOfNode",
    value: function displayNameOfNode(node) {
      if (!node) return null;
      var type = node.type,
          $$typeof = node.$$typeof;
      var adapter = this;
      var nodeType = type || $$typeof; // newer node types may be undefined, so only test if the nodeType exists

      if (nodeType) {
        switch (nodeType) {
          case _reactIs.ConcurrentMode || NaN:
            return 'ConcurrentMode';

          case _reactIs.Fragment || NaN:
            return 'Fragment';

          case _reactIs.StrictMode || NaN:
            return 'StrictMode';

          case _reactIs.Profiler || NaN:
            return 'Profiler';

          case _reactIs.Portal || NaN:
            return 'Portal';

          case _reactIs.Suspense || NaN:
            return 'Suspense';

          default:
        }
      }

      var $$typeofType = type && type.$$typeof;

      switch ($$typeofType) {
        case _reactIs.ContextConsumer || NaN:
          return 'ContextConsumer';

        case _reactIs.ContextProvider || NaN:
          return 'ContextProvider';

        case _reactIs.Memo || NaN:
          {
            var nodeName = (0, _enzymeAdapterUtils.displayNameOfNode)(node);
            return typeof nodeName === 'string' ? nodeName : "Memo(".concat(adapter.displayNameOfNode(type), ")");
          }

        case _reactIs.ForwardRef || NaN:
          {
            if (type.displayName) {
              return type.displayName;
            }

            var name = adapter.displayNameOfNode({
              type: type.render
            });
            return name ? "ForwardRef(".concat(name, ")") : 'ForwardRef';
          }

        case _reactIs.Lazy || NaN:
          {
            return 'lazy';
          }

        default:
          return (0, _enzymeAdapterUtils.displayNameOfNode)(node);
      }
    }
  }, {
    key: "isValidElement",
    value: function isValidElement(element) {
      return (0, _reactIs.isElement)(element);
    }
  }, {
    key: "isValidElementType",
    value: function isValidElementType(object) {
      return !!object && (0, _reactIs.isValidElementType)(object);
    }
  }, {
    key: "isFragment",
    value: function isFragment(fragment) {
      return (0, _Utils.typeOfNode)(fragment) === _reactIs.Fragment;
    }
  }, {
    key: "isCustomComponent",
    value: function isCustomComponent(type) {
      var fakeElement = makeFakeElement(type);
      return !!type && (typeof type === 'function' || (0, _reactIs.isForwardRef)(fakeElement) || (0, _reactIs.isContextProvider)(fakeElement) || (0, _reactIs.isContextConsumer)(fakeElement) || (0, _reactIs.isSuspense)(fakeElement));
    }
  }, {
    key: "isContextConsumer",
    value: function isContextConsumer(type) {
      return !!type && (0, _reactIs.isContextConsumer)(makeFakeElement(type));
    }
  }, {
    key: "isCustomComponentElement",
    value: function isCustomComponentElement(inst) {
      if (!inst || !this.isValidElement(inst)) {
        return false;
      }

      return this.isCustomComponent(inst.type);
    }
  }, {
    key: "getProviderFromConsumer",
    value: function getProviderFromConsumer(Consumer) {
      // React stores references to the Provider on a Consumer differently across versions.
      if (Consumer) {
        var Provider;

        if (Consumer._context) {
          // check this first, to avoid a deprecation warning
          Provider = Consumer._context.Provider;
        } else if (Consumer.Provider) {
          Provider = Consumer.Provider;
        }

        if (Provider) {
          return Provider;
        }
      }

      throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');
    }
  }, {
    key: "createElement",
    value: function createElement() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      return wrapAct(function () {
        return /*#__PURE__*/_react["default"].createElement.apply(_react["default"], args);
      });
    }
  }, {
    key: "wrapWithWrappingComponent",
    value: function wrapWithWrappingComponent(node, options) {
      return {
        RootFinder: _enzymeAdapterUtils.RootFinder,
        node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react["default"].createElement, node, options)
      };
    }
  }]);

  return ReactEighteenAdapter;
}(_enzyme.EnzymeAdapter);

module.exports = ReactEighteenAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJub2RlQW5kU2libGluZ3NBcnJheSIsIm5vZGVXaXRoU2libGluZyIsImFycmF5Iiwibm9kZSIsInB1c2giLCJzaWJsaW5nIiwiZmxhdHRlbiIsImFyciIsInJlc3VsdCIsInN0YWNrIiwiaSIsImxlbmd0aCIsIm4iLCJwb3AiLCJlbCIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVUeXBlRnJvbVR5cGUiLCJ0eXBlIiwiUG9ydGFsIiwidXRpbE5vZGVUeXBlRnJvbVR5cGUiLCJpc01lbW8iLCJjb21wYXJlTm9kZVR5cGVPZiIsIk1lbW8iLCJpc0xhenkiLCJMYXp5IiwidW5tZW1vVHlwZSIsImNoZWNrSXNTdXNwZW5zZUFuZENsb25lRWxlbWVudCIsInN1c3BlbnNlRmFsbGJhY2siLCJpc1N1c3BlbnNlIiwiY2hpbGRyZW4iLCJwcm9wcyIsImZhbGxiYWNrIiwicmVwbGFjZUxhenlXaXRoRmFsbGJhY2siLCJGYWtlU3VzcGVuc2VXcmFwcGVyIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiZWxlbWVudFRvVHJlZSIsImlzUG9ydGFsIiwidXRpbEVsZW1lbnRUb1RyZWUiLCJjb250YWluZXJJbmZvIiwibm9kZVR5cGUiLCJrZXkiLCJlbnN1cmVLZXlPclVuZGVmaW5lZCIsInJlZiIsImluc3RhbmNlIiwicmVuZGVyZWQiLCJ0b1RyZWUiLCJ2bm9kZSIsImZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIiwidGFnIiwiVEFHX0NPREVTIiwiSG9zdFJvb3QiLCJjaGlsZHJlblRvVHJlZSIsImNoaWxkIiwiSG9zdFBvcnRhbCIsInN0YXRlTm9kZSIsIm1lbW9pemVkUHJvcHMiLCJJbmRldGVybWluYXRlQ29tcG9uZW50IiwiSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50IiwiQ2xhc3NDb21wb25lbnQiLCJGdW5jdGlvbkNvbXBvbmVudCIsIk1lbW9DbGFzcyIsImVsZW1lbnRUeXBlIiwiTWVtb1NGQyIsInJlbmRlcmVkTm9kZXMiLCJtYXAiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJEZWh5ZHJhdGVkRnJhZ21lbnQiLCJGcmFnbWVudCIsIk1vZGUiLCJDb250ZXh0UHJvdmlkZXIiLCJDb250ZXh0Q29uc3VtZXIiLCJQcm9maWxlciIsIk1lbW9Db21wb25lbnQiLCJTaW1wbGVNZW1vQ29tcG9uZW50IiwiRm9yd2FyZFJlZiIsInBlbmRpbmdQcm9wcyIsIlN1c3BlbnNlTGlzdENvbXBvbmVudCIsIlN1c3BlbnNlQ29tcG9uZW50IiwiU3VzcGVuc2UiLCJMYXp5Q29tcG9uZW50IiwiU2NvcGVDb21wb25lbnQiLCJPZmZzY3JlZW5Db21wb25lbnQiLCJMZWdhY3lIaWRkZW5Db21wb25lbnQiLCJDYWNoZUNvbXBvbmVudCIsIlRyYWNpbmdNYXJrZXJDb21wb25lbnQiLCJFcnJvciIsIm5vZGVUb0hvc3ROb2RlIiwiX25vZGUiLCJtYXBwZXIiLCJpdGVtIiwiZmluZERPTU5vZGUiLCJnZXRFbXB0eVN0YXRlVmFsdWUiLCJFbXB0eVN0YXRlIiwiQ29tcG9uZW50IiwidGVzdFJlbmRlcmVyIiwiU2hhbGxvd1JlbmRlcmVyIiwicmVuZGVyIiwiX2luc3RhbmNlIiwic3RhdGUiLCJ3cmFwQWN0IiwiZm4iLCJyZXR1cm5WYWwiLCJUZXN0VXRpbHMiLCJhY3QiLCJnZXRQcm92aWRlckRlZmF1bHRWYWx1ZSIsIlByb3ZpZGVyIiwiX2NvbnRleHQiLCJfZGVmYXVsdFZhbHVlIiwiX2N1cnJlbnRWYWx1ZSIsIm1ha2VGYWtlRWxlbWVudCIsIiQkdHlwZW9mIiwiRWxlbWVudCIsImlzU3RhdGVmdWwiLCJwcm90b3R5cGUiLCJpc1JlYWN0Q29tcG9uZW50IiwiX19yZWFjdEF1dG9CaW5kUGFpcnMiLCJSZWFjdEVpZ2h0ZWVuQWRhcHRlciIsIlJlYWN0V3JhcHBlciIsInNldFByb3BzIiwic2V0U3RhdGUiLCJhcmdzIiwiYXBwbHkiLCJsaWZlY3ljbGVzIiwib3B0aW9ucyIsImVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGUiLCJsZWdhY3lDb250ZXh0TW9kZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm9uU2V0U3RhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWciLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsInNraXBzQ29tcG9uZW50RGlkVXBkYXRlT25OdWxsaXNoIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2FsbGVkQnlSZW5kZXJlciIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImFzc2VydERvbUF2YWlsYWJsZSIsImhhcyIsIlR5cGVFcnJvciIsImF0dGFjaFRvIiwiaHlkcmF0ZUluIiwid3JhcHBpbmdDb21wb25lbnRQcm9wcyIsImRvbU5vZGUiLCJnbG9iYWwiLCJkb2N1bWVudCIsImFkYXB0ZXIiLCJyb290IiwiY29udGV4dCIsImNhbGxiYWNrIiwid3JhcHBlclByb3BzIiwicmVmUHJvcCIsIndyYXBwZWRFbCIsIlJlYWN0V3JhcHBlckNvbXBvbmVudCIsImNyZWF0ZU1vdW50V3JhcHBlciIsImh5ZHJhdGVSb290IiwiY3JlYXRlUm9vdCIsImZsdXNoU3luYyIsImdldFB1YmxpY1Jvb3RJbnN0YW5jZSIsInNldENoaWxkUHJvcHMiLCJ1bm1vdW50IiwiZ2V0Tm9kZSIsImdldE5vZGVGcm9tUm9vdEZpbmRlciIsImlzQ3VzdG9tQ29tcG9uZW50IiwiX3JlYWN0SW50ZXJuYWxzIiwic2ltdWxhdGVFcnJvciIsIm5vZGVIaWVyYXJjaHkiLCJyb290Tm9kZSIsImVycm9yIiwiaXNFcnJvckJvdW5kYXJ5IiwiZWxJbnN0YW5jZSIsImNvbXBvbmVudERpZENhdGNoIiwiZmluZCIsImNhdGNoaW5nSW5zdGFuY2UiLCJjYXRjaGluZ1R5cGUiLCJkaXNwbGF5TmFtZU9mTm9kZSIsInNpbXVsYXRlRXZlbnQiLCJldmVudCIsIm1vY2siLCJtYXBwZWRFdmVudCIsIm1hcE5hdGl2ZUV2ZW50TmFtZXMiLCJldmVudEZuIiwiU2ltdWxhdGUiLCJiYXRjaGVkVXBkYXRlcyIsImdldFdyYXBwaW5nQ29tcG9uZW50UmVuZGVyZXIiLCJnZXRXcmFwcGluZ0NvbXBvbmVudE1vdW50UmVuZGVyZXIiLCJpbnN0IiwiZ2V0TW91bnRXcmFwcGVySW5zdGFuY2UiLCJ3cmFwSW52b2tlIiwicmVuZGVyZXIiLCJpc0RPTSIsImNhY2hlZE5vZGUiLCJsYXN0Q29tcG9uZW50Iiwid3JhcHBlZENvbXBvbmVudCIsInNlbnRpbmVsIiwid3JhcFB1cmVDb21wb25lbnQiLCJjb21wYXJlIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwibmV4dFByb3BzIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJtZW1vaXplZCIsInByZXZQcm9wcyIsIndyYXBwZWRDb21wb25lbnRGbiIsInNob3VsZFVwZGF0ZSIsInNoYWxsb3dFcXVhbCIsImRlZmF1bHRQcm9wcyIsIk9iamVjdCIsImFzc2lnbiIsImRpc3BsYXlOYW1lIiwid3JhcEZ1bmN0aW9uYWxDb21wb25lbnQiLCJyZW5kZXJFbGVtZW50IiwiZWxDb25maWciLCJyZXN0IiwicmVuZGVyZWRFbCIsInR5cGVJc0V4aXN0ZWQiLCJjbG9uZWRFbCIsImVsZW1lbnRJc0NoYW5nZWQiLCJ1bm1hc2tlZENvbnRleHQiLCJwcm92aWRlclZhbHVlcyIsIk1hcCIsImlzQ29udGV4dFByb3ZpZGVyIiwic2V0IiwidmFsdWUiLCJNb2NrUHJvdmlkZXIiLCJ3aXRoU2V0U3RhdGVBbGxvd2VkIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJnZXRQcm92aWRlckZyb21Db25zdW1lciIsImdldCIsIk1vY2tDb25zdW1lciIsImdldE1hc2tlZENvbnRleHQiLCJjb250ZXh0VHlwZXMiLCJJbm5lckNvbXAiLCJpc0NvbXBvbmVudFN0YXRlZnVsIiwic3B5TWV0aG9kIiwib3JpZ2luYWxNZXRob2QiLCJfdXBkYXRlQ2xhc3NDb21wb25lbnQiLCJjbG9uZWRQcm9wcyIsInJlc3RvcmUiLCJlbXB0eVN0YXRlVmFsdWUiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIm91dHB1dCIsImdldFJlbmRlck91dHB1dCIsImNvbmNhdCIsImhhbmRsZXIiLCJwcm9wRnJvbUV2ZW50IiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImhpZXJhcmNoeSIsImdldENvbXBvbmVudFN0YWNrIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJDb250ZXh0V3JhcHBlciIsImNyZWF0ZVJlbmRlcldyYXBwZXIiLCJSZWFjdERPTVNlcnZlciIsInJlbmRlclRvU3RhdGljTWFya3VwIiwibW9kZSIsIkVuenltZUFkYXB0ZXIiLCJNT0RFUyIsIk1PVU5UIiwiY3JlYXRlTW91bnRSZW5kZXJlciIsIlNIQUxMT1ciLCJjcmVhdGVTaGFsbG93UmVuZGVyZXIiLCJTVFJJTkciLCJjcmVhdGVTdHJpbmdSZW5kZXJlciIsImVsZW1lbnQiLCJ3cmFwIiwicHJvcHNXaXRoS2V5c0FuZFJlZiIsIm1hdGNoaW5nVHlwZSIsInN1cHBvcnRzQXJyYXkiLCJub2RlcyIsImZpbHRlciIsIkJvb2xlYW4iLCJDb25jdXJyZW50TW9kZSIsIk5hTiIsIlN0cmljdE1vZGUiLCIkJHR5cGVvZlR5cGUiLCJub2RlTmFtZSIsIm5hbWUiLCJpc0VsZW1lbnQiLCJvYmplY3QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJmcmFnbWVudCIsInR5cGVPZk5vZGUiLCJmYWtlRWxlbWVudCIsImlzRm9yd2FyZFJlZiIsImlzVmFsaWRFbGVtZW50IiwiQ29uc3VtZXIiLCJSb290RmluZGVyIiwid3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyIuLi9zcmMvUmVhY3RFaWdodGVlbkFkYXB0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZsdXNoU3luYywgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgY3JlYXRlUm9vdCwgaHlkcmF0ZVJvb3QgfSBmcm9tICdyZWFjdC1kb20vY2xpZW50JztcbmltcG9ydCBSZWFjdERPTVNlcnZlciBmcm9tICdyZWFjdC1kb20vc2VydmVyJztcbmltcG9ydCBTaGFsbG93UmVuZGVyZXIgZnJvbSAncmVhY3QtdGVzdC1yZW5kZXJlci9zaGFsbG93JztcbmltcG9ydCBUZXN0VXRpbHMgZnJvbSAncmVhY3QtZG9tL3Rlc3QtdXRpbHMnO1xuaW1wb3J0IGNoZWNrUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnO1xuaW1wb3J0IGhhcyBmcm9tICdoYXMnO1xuaW1wb3J0IHtcbiAgQ29uY3VycmVudE1vZGUsXG4gIENvbnRleHRDb25zdW1lcixcbiAgQ29udGV4dFByb3ZpZGVyLFxuICBFbGVtZW50LFxuICBGb3J3YXJkUmVmLFxuICBGcmFnbWVudCxcbiAgaXNDb250ZXh0Q29uc3VtZXIsXG4gIGlzQ29udGV4dFByb3ZpZGVyLFxuICBpc0VsZW1lbnQsXG4gIGlzRm9yd2FyZFJlZixcbiAgaXNQb3J0YWwsXG4gIGlzU3VzcGVuc2UsXG4gIGlzVmFsaWRFbGVtZW50VHlwZSxcbiAgTGF6eSxcbiAgTWVtbyxcbiAgUG9ydGFsLFxuICBQcm9maWxlcixcbiAgU3RyaWN0TW9kZSxcbiAgU3VzcGVuc2UsXG59IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCB7IEVuenltZUFkYXB0ZXIsIFJlYWN0V3JhcHBlciB9IGZyb20gJ2VuenltZSc7XG5pbXBvcnQgeyB0eXBlT2ZOb2RlIH0gZnJvbSAnZW56eW1lL2J1aWxkL1V0aWxzJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnZW56eW1lLXNoYWxsb3ctZXF1YWwnO1xuaW1wb3J0IHtcbiAgZGlzcGxheU5hbWVPZk5vZGUsXG4gIGVsZW1lbnRUb1RyZWUgYXMgdXRpbEVsZW1lbnRUb1RyZWUsXG4gIG5vZGVUeXBlRnJvbVR5cGUgYXMgdXRpbE5vZGVUeXBlRnJvbVR5cGUsXG4gIG1hcE5hdGl2ZUV2ZW50TmFtZXMsXG4gIHByb3BGcm9tRXZlbnQsXG4gIGFzc2VydERvbUF2YWlsYWJsZSxcbiAgd2l0aFNldFN0YXRlQWxsb3dlZCxcbiAgY3JlYXRlUmVuZGVyV3JhcHBlcixcbiAgY3JlYXRlTW91bnRXcmFwcGVyLFxuICBwcm9wc1dpdGhLZXlzQW5kUmVmLFxuICBlbnN1cmVLZXlPclVuZGVmaW5lZCxcbiAgc2ltdWxhdGVFcnJvcixcbiAgd3JhcCxcbiAgZ2V0TWFza2VkQ29udGV4dCxcbiAgZ2V0Q29tcG9uZW50U3RhY2ssXG4gIFJvb3RGaW5kZXIsXG4gIGdldE5vZGVGcm9tUm9vdEZpbmRlcixcbiAgd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudCxcbiAgZ2V0V3JhcHBpbmdDb21wb25lbnRNb3VudFJlbmRlcmVyLFxuICBjb21wYXJlTm9kZVR5cGVPZixcbiAgc3B5TWV0aG9kLFxuICBnZXRQdWJsaWNSb290SW5zdGFuY2UsXG4gIFRBR19DT0RFUyxcbn0gZnJvbSAnQGNoYWxiZXJ0L2VuenltZS1hZGFwdGVyLXV0aWxzJztcbmltcG9ydCBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCBmcm9tICcuL2ZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoJztcblxuLy8gTGF6aWx5IHBvcHVsYXRlZCBpZiBET00gaXMgYXZhaWxhYmxlLlxuXG5mdW5jdGlvbiBub2RlQW5kU2libGluZ3NBcnJheShub2RlV2l0aFNpYmxpbmcpIHtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgbGV0IG5vZGUgPSBub2RlV2l0aFNpYmxpbmc7XG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBhcnJheS5wdXNoKG5vZGUpO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuKGFycikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbeyBpOiAwLCBhcnJheTogYXJyIH1dO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgY29uc3QgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHdoaWxlIChuLmkgPCBuLmFycmF5Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZWwgPSBuLmFycmF5W24uaV07XG4gICAgICBuLmkgKz0gMTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgICBzdGFjay5wdXNoKG4pO1xuICAgICAgICBzdGFjay5wdXNoKHsgaTogMCwgYXJyYXk6IGVsIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGVsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbm9kZVR5cGVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09PSBQb3J0YWwpIHtcbiAgICByZXR1cm4gJ3BvcnRhbCc7XG4gIH1cblxuICByZXR1cm4gdXRpbE5vZGVUeXBlRnJvbVR5cGUodHlwZSk7XG59XG5cbmZ1bmN0aW9uIGlzTWVtbyh0eXBlKSB7XG4gIHJldHVybiBjb21wYXJlTm9kZVR5cGVPZih0eXBlLCBNZW1vKTtcbn1cblxuZnVuY3Rpb24gaXNMYXp5KHR5cGUpIHtcbiAgcmV0dXJuIGNvbXBhcmVOb2RlVHlwZU9mKHR5cGUsIExhenkpO1xufVxuXG5mdW5jdGlvbiB1bm1lbW9UeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzTWVtbyh0eXBlKSA/IHR5cGUudHlwZSA6IHR5cGU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNTdXNwZW5zZUFuZENsb25lRWxlbWVudChlbCwgeyBzdXNwZW5zZUZhbGxiYWNrIH0pIHtcbiAgaWYgKCFpc1N1c3BlbnNlKGVsKSkge1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIGxldCB7IGNoaWxkcmVuIH0gPSBlbC5wcm9wcztcblxuICBpZiAoc3VzcGVuc2VGYWxsYmFjaykge1xuICAgIGNvbnN0IHsgZmFsbGJhY2sgfSA9IGVsLnByb3BzO1xuICAgIGNoaWxkcmVuID0gcmVwbGFjZUxhenlXaXRoRmFsbGJhY2soY2hpbGRyZW4sIGZhbGxiYWNrKTtcbiAgfVxuXG4gIGNvbnN0IEZha2VTdXNwZW5zZVdyYXBwZXIgPSAocHJvcHMpID0+XG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChlbC50eXBlLCB7IC4uLmVsLnByb3BzLCAuLi5wcm9wcyB9LCBjaGlsZHJlbik7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEZha2VTdXNwZW5zZVdyYXBwZXIsIG51bGwsIGNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudFRvVHJlZShlbCkge1xuICBpZiAoIWlzUG9ydGFsKGVsKSkge1xuICAgIHJldHVybiB1dGlsRWxlbWVudFRvVHJlZShlbCwgZWxlbWVudFRvVHJlZSk7XG4gIH1cblxuICBjb25zdCB7IGNoaWxkcmVuLCBjb250YWluZXJJbmZvIH0gPSBlbDtcbiAgY29uc3QgcHJvcHMgPSB7IGNoaWxkcmVuLCBjb250YWluZXJJbmZvIH07XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlVHlwZTogJ3BvcnRhbCcsXG4gICAgdHlwZTogUG9ydGFsLFxuICAgIHByb3BzLFxuICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQoZWwua2V5KSxcbiAgICByZWY6IGVsLnJlZiB8fCBudWxsLFxuICAgIGluc3RhbmNlOiBudWxsLFxuICAgIHJlbmRlcmVkOiBlbGVtZW50VG9UcmVlKGVsLmNoaWxkcmVuKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9UcmVlKHZub2RlKSB7XG4gIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVE9ETyhsbXIpOiBJJ20gbm90IHJlYWxseSBzdXJlIEkgdW5kZXJzdGFuZCB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHdoYXRcbiAgLy8gaSBzaG91bGQgYmUgZG9pbmcsIG9yIGlmIHRoaXMgaXMgYSBoYWNrIGZvciBzb21ldGhpbmcgaSdtIGRvaW5nIHdyb25nXG4gIC8vIHNvbWV3aGVyZSBlbHNlLiBTaG91bGQgdGFsayB0byBzZWJhc3RpYW4gYWJvdXQgdGhpcyBwZXJoYXBzXG4gIGNvbnN0IG5vZGUgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCh2bm9kZSk7XG5cbiAgc3dpdGNoIChub2RlLnRhZykge1xuICAgIGNhc2UgVEFHX0NPREVTLkhvc3RSb290OlxuICAgICAgcmV0dXJuIGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpO1xuICAgIGNhc2UgVEFHX0NPREVTLkhvc3RQb3J0YWw6IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhdGVOb2RlOiB7IGNvbnRhaW5lckluZm8gfSxcbiAgICAgICAgbWVtb2l6ZWRQcm9wczogY2hpbGRyZW4sXG4gICAgICB9ID0gbm9kZTtcbiAgICAgIGNvbnN0IHByb3BzID0geyBjb250YWluZXJJbmZvLCBjaGlsZHJlbiB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdwb3J0YWwnLFxuICAgICAgICB0eXBlOiBQb3J0YWwsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgVEFHX0NPREVTLkluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIGNhc2UgVEFHX0NPREVTLkluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIFRBR19DT0RFUy5DbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnY2xhc3MnLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIGNhc2UgVEFHX0NPREVTLkZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpLFxuICAgICAgfTtcbiAgICBjYXNlIFRBR19DT0RFUy5NZW1vQ2xhc3M6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2NsYXNzJyxcbiAgICAgICAgdHlwZTogbm9kZS5lbGVtZW50VHlwZS50eXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBub2RlLnN0YXRlTm9kZSxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQuY2hpbGQpLFxuICAgICAgfTtcbiAgICBjYXNlIFRBR19DT0RFUy5NZW1vU0ZDOiB7XG4gICAgICBsZXQgcmVuZGVyZWROb2RlcyA9IGZsYXR0ZW4obm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZS5jaGlsZCkubWFwKHRvVHJlZSkpO1xuICAgICAgaWYgKHJlbmRlcmVkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbmRlcmVkTm9kZXMgPSBbbm9kZS5tZW1vaXplZFByb3BzLmNoaWxkcmVuXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICB0eXBlOiBub2RlLmVsZW1lbnRUeXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWROb2RlcyxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgVEFHX0NPREVTLkhvc3RDb21wb25lbnQ6IHtcbiAgICAgIGxldCByZW5kZXJlZE5vZGVzID0gZmxhdHRlbihub2RlQW5kU2libGluZ3NBcnJheShub2RlLmNoaWxkKS5tYXAodG9UcmVlKSk7XG4gICAgICBpZiAocmVuZGVyZWROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVuZGVyZWROb2RlcyA9IFtub2RlLm1lbW9pemVkUHJvcHMuY2hpbGRyZW5dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdob3N0JyxcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBub2RlLnN0YXRlTm9kZSxcbiAgICAgICAgcmVuZGVyZWQ6IHJlbmRlcmVkTm9kZXMsXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFRBR19DT0RFUy5Ib3N0VGV4dDpcbiAgICAgIHJldHVybiBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgY2FzZSBUQUdfQ09ERVMuRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgIGNhc2UgVEFHX0NPREVTLkZyYWdtZW50OlxuICAgIGNhc2UgVEFHX0NPREVTLk1vZGU6XG4gICAgY2FzZSBUQUdfQ09ERVMuQ29udGV4dFByb3ZpZGVyOlxuICAgIGNhc2UgVEFHX0NPREVTLkNvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKTtcbiAgICBjYXNlIFRBR19DT0RFUy5Qcm9maWxlcjpcbiAgICBjYXNlIFRBR19DT0RFUy5NZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgVEFHX0NPREVTLlNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBUQUdfQ09ERVMuRm9yd2FyZFJlZjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5wZW5kaW5nUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFRBR19DT0RFUy5TdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgY2FzZSBUQUdfQ09ERVMuU3VzcGVuc2VDb21wb25lbnQ6IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZmxhdHRlbihub2RlQW5kU2libGluZ3NBcnJheShub2RlLmNoaWxkLmNoaWxkKS5tYXAodG9UcmVlKSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICB0eXBlOiBTdXNwZW5zZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuIDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFRBR19DT0RFUy5MYXp5Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpO1xuICAgIGNhc2UgVEFHX0NPREVTLlNjb3BlQ29tcG9uZW50OlxuICAgIGNhc2UgVEFHX0NPREVTLk9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIFRBR19DT0RFUy5MZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgY2FzZSBUQUdfQ09ERVMuQ2FjaGVDb21wb25lbnQ6XG4gICAgY2FzZSBUQUdfQ09ERVMuVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgIHJldHVybiB0b1RyZWUobm9kZS5jaGlsZCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lIEludGVybmFsIEVycm9yOiB1bmtub3duIG5vZGUgd2l0aCB0YWcgJHtub2RlLnRhZ31gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGlsZHJlblRvVHJlZShub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZSk7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRvVHJlZShjaGlsZHJlblswXSk7XG4gIH1cbiAgcmV0dXJuIGZsYXR0ZW4oY2hpbGRyZW4ubWFwKHRvVHJlZSkpO1xufVxuXG5mdW5jdGlvbiBub2RlVG9Ib3N0Tm9kZShfbm9kZSkge1xuICAvLyBOT1RFKGxtcik6IG5vZGUgY291bGQgYmUgYSBmdW5jdGlvbiBjb21wb25lbnRcbiAgLy8gd2hpY2ggd29udCBoYXZlIGFuIGluc3RhbmNlIHByb3AsIGJ1dCB3ZSBjYW4gZ2V0IHRoZVxuICAvLyBob3N0IG5vZGUgYXNzb2NpYXRlZCB3aXRoIGl0cyByZXR1cm4gdmFsdWUgYXQgdGhhdCBwb2ludC5cbiAgLy8gQWx0aG91Z2ggdGhpcyBicmVha3MgZG93biBpZiB0aGUgcmV0dXJuIHZhbHVlIGlzIGFuIGFycmF5LFxuICAvLyBhcyBpcyBwb3NzaWJsZSB3aXRoIFJlYWN0IDE2LlxuICBsZXQgbm9kZSA9IF9ub2RlO1xuICB3aGlsZSAobm9kZSAmJiAhQXJyYXkuaXNBcnJheShub2RlKSAmJiBub2RlLmluc3RhbmNlID09PSBudWxsKSB7XG4gICAgbm9kZSA9IG5vZGUucmVuZGVyZWQ7XG4gIH1cbiAgLy8gaWYgdGhlIFNGQyByZXR1cm5lZCBudWxsIGVmZmVjdGl2ZWx5LCB0aGVyZSBpcyBubyBob3N0IG5vZGUuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgbWFwcGVyID0gKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSAmJiBpdGVtLmluc3RhbmNlKSByZXR1cm4gZmluZERPTU5vZGUoaXRlbS5pbnN0YW5jZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUubWFwKG1hcHBlcik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5yZW5kZXJlZCkgJiYgbm9kZS5ub2RlVHlwZSA9PT0gJ2NsYXNzJykge1xuICAgIHJldHVybiBub2RlLnJlbmRlcmVkLm1hcChtYXBwZXIpO1xuICB9XG4gIHJldHVybiBtYXBwZXIobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VMYXp5V2l0aEZhbGxiYWNrKG5vZGUsIGZhbGxiYWNrKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUubWFwKChlbCkgPT4gcmVwbGFjZUxhenlXaXRoRmFsbGJhY2soZWwsIGZhbGxiYWNrKSk7XG4gIH1cbiAgaWYgKGlzTGF6eShub2RlLnR5cGUpKSB7XG4gICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tcmVwbGFjZUxhenlXaXRoRmFsbGJhY2snKTtcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5ub2RlLFxuICAgIHByb3BzOiB7XG4gICAgICAuLi5ub2RlLnByb3BzLFxuICAgICAgY2hpbGRyZW46IHJlcGxhY2VMYXp5V2l0aEZhbGxiYWNrKG5vZGUucHJvcHMuY2hpbGRyZW4sIGZhbGxiYWNrKSxcbiAgICB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFbXB0eVN0YXRlVmFsdWUoKSB7XG4gIC8vIHRoaXMgaGFuZGxlcyBhIGJ1ZyBpbiBSZWFjdCAxNi4wIC0gMTYuMlxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2NvbW1pdC8zOWJlODM1NjVjNjVmOWM1MjIxNTBlNTIzNzUxNjc1NjhhMmExNDU5XG4gIC8vIGFsc28gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExOTY1XG5cbiAgY2xhc3MgRW1wdHlTdGF0ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRlc3RSZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcbiAgdGVzdFJlbmRlcmVyLnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KEVtcHR5U3RhdGUpKTtcbiAgcmV0dXJuIHRlc3RSZW5kZXJlci5faW5zdGFuY2Uuc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHdyYXBBY3QoZm4pIHtcbiAgbGV0IHJldHVyblZhbDtcbiAgVGVzdFV0aWxzLmFjdCgoKSA9PiB7XG4gICAgcmV0dXJuVmFsID0gZm4oKTtcbiAgfSk7XG4gIHJldHVybiByZXR1cm5WYWw7XG59XG5cbmZ1bmN0aW9uIGdldFByb3ZpZGVyRGVmYXVsdFZhbHVlKFByb3ZpZGVyKSB7XG4gIC8vIFJlYWN0IHN0b3JlcyByZWZlcmVuY2VzIHRvIHRoZSBQcm92aWRlcidzIGRlZmF1bHRWYWx1ZSBkaWZmZXJlbnRseSBhY3Jvc3MgdmVyc2lvbnMuXG4gIGlmICgnX2RlZmF1bHRWYWx1ZScgaW4gUHJvdmlkZXIuX2NvbnRleHQpIHtcbiAgICByZXR1cm4gUHJvdmlkZXIuX2NvbnRleHQuX2RlZmF1bHRWYWx1ZTtcbiAgfVxuICBpZiAoJ19jdXJyZW50VmFsdWUnIGluIFByb3ZpZGVyLl9jb250ZXh0KSB7XG4gICAgcmV0dXJuIFByb3ZpZGVyLl9jb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IGNhbuKAmXQgZmlndXJlIG91dCBob3cgdG8gZ2V0IFByb3ZpZGVy4oCZcyBkZWZhdWx0IHZhbHVlJyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VGYWtlRWxlbWVudCh0eXBlKSB7XG4gIHJldHVybiB7ICQkdHlwZW9mOiBFbGVtZW50LCB0eXBlIH07XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGVmdWwoQ29tcG9uZW50KSB7XG4gIHJldHVybiAoXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgIChDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgfHwgQXJyYXkuaXNBcnJheShDb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnMpKSAvLyBmYWxsYmFjayBmb3IgY3JlYXRlQ2xhc3MgY29tcG9uZW50c1xuICApO1xufVxuXG5jbGFzcyBSZWFjdEVpZ2h0ZWVuQWRhcHRlciBleHRlbmRzIEVuenltZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gTW9ua2V5IHBhdGNoaW5nIHNvIHdlIGRvbid0IGhhdmUgdG8gd3JhcCBpbiAnYWN0JyBlYWNoIHRpbWVcbiAgICBjb25zdCB7IHNldFByb3BzLCBzZXRTdGF0ZSB9ID0gUmVhY3RXcmFwcGVyLnByb3RvdHlwZTtcbiAgICBSZWFjdFdyYXBwZXIucHJvdG90eXBlLnNldFByb3BzID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiB3cmFwQWN0KCgpID0+IHNldFByb3BzLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICB9O1xuICAgIFJlYWN0V3JhcHBlci5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgcmV0dXJuIHdyYXBBY3QoKCkgPT4gc2V0U3RhdGUuYXBwbHkodGhpcywgYXJncykpO1xuICAgIH07XG5cbiAgICBjb25zdCB7IGxpZmVjeWNsZXMgfSA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICBlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlOiB0cnVlLCAvLyBUT0RPOiByZW1vdmUsIHNlbXZlci1tYWpvclxuICAgICAgbGVnYWN5Q29udGV4dE1vZGU6ICdwYXJlbnQnLFxuICAgICAgbGlmZWN5Y2xlczoge1xuICAgICAgICAuLi5saWZlY3ljbGVzLFxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGU6IHtcbiAgICAgICAgICBvblNldFN0YXRlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHtcbiAgICAgICAgICBoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWc6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgc2V0U3RhdGU6IHtcbiAgICAgICAgICBza2lwc0NvbXBvbmVudERpZFVwZGF0ZU9uTnVsbGlzaDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0OiB7XG4gICAgICAgICAgY2FsbGVkQnlSZW5kZXJlcjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZU1vdW50UmVuZGVyZXIob3B0aW9ucykge1xuICAgIGFzc2VydERvbUF2YWlsYWJsZSgnbW91bnQnKTtcbiAgICBpZiAoaGFzKG9wdGlvbnMsICdzdXNwZW5zZUZhbGxiYWNrJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BzdXNwZW5zZUZhbGxiYWNrYCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgbW91bnRgIHJlbmRlcmVyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBhdHRhY2hUbywgaHlkcmF0ZUluLCB3cmFwcGluZ0NvbXBvbmVudFByb3BzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRvbU5vZGUgPSBoeWRyYXRlSW4gfHwgYXR0YWNoVG8gfHwgZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBpbnN0YW5jZSA9IG51bGw7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXM7XG5cbiAgICBsZXQgcm9vdDtcblxuICAgIHJldHVybiB7XG4gICAgICByZW5kZXIoZWwsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB3cmFwQWN0KCgpID0+IHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHJlZiB9ID0gZWw7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgIENvbXBvbmVudDogdHlwZSxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIHdyYXBwaW5nQ29tcG9uZW50UHJvcHMsXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIC4uLihyZWYgJiYgeyByZWZQcm9wOiByZWYgfSksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXQgd3JhcHBlZEVsO1xuXG4gICAgICAgICAgICBjb25zdCBSZWFjdFdyYXBwZXJDb21wb25lbnQgPSBjcmVhdGVNb3VudFdyYXBwZXIoZWwsIHsgLi4ub3B0aW9ucywgYWRhcHRlciB9KTtcbiAgICAgICAgICAgIHdyYXBwZWRFbCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RXcmFwcGVyQ29tcG9uZW50LCB3cmFwcGVyUHJvcHMpO1xuICAgICAgICAgICAgcm9vdCA9IGh5ZHJhdGVJbiA/IGh5ZHJhdGVSb290KGRvbU5vZGUsIHdyYXBwZWRFbCkgOiBjcmVhdGVSb290KGRvbU5vZGUpO1xuXG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICByb290LnJlbmRlcih3cmFwcGVkRWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldENoaWxkUHJvcHMoZWwucHJvcHMsIGNvbnRleHQsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHVubW91bnQoKSB7XG4gICAgICAgIHdyYXBBY3QoKCkgPT4ge1xuICAgICAgICAgIHJvb3Q/LnVubW91bnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGluc3RhbmNlID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXROb2RlKCkge1xuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldE5vZGVGcm9tUm9vdEZpbmRlcihcbiAgICAgICAgICBhZGFwdGVyLmlzQ3VzdG9tQ29tcG9uZW50LFxuICAgICAgICAgIHRvVHJlZShpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbHMpLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFcnJvcihub2RlSGllcmFyY2h5LCByb290Tm9kZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgaXNFcnJvckJvdW5kYXJ5ID0gKHsgaW5zdGFuY2U6IGVsSW5zdGFuY2UsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlICYmIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVsSW5zdGFuY2UgJiYgZWxJbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB7IGluc3RhbmNlOiBjYXRjaGluZ0luc3RhbmNlLCB0eXBlOiBjYXRjaGluZ1R5cGUgfSA9XG4gICAgICAgICAgbm9kZUhpZXJhcmNoeS5maW5kKGlzRXJyb3JCb3VuZGFyeSkgfHwge307XG5cbiAgICAgICAgVGVzdFV0aWxzLmFjdCgoKSA9PiB7XG4gICAgICAgICAgc2ltdWxhdGVFcnJvcihcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgY2F0Y2hpbmdJbnN0YW5jZSxcbiAgICAgICAgICAgIHJvb3ROb2RlLFxuICAgICAgICAgICAgbm9kZUhpZXJhcmNoeSxcbiAgICAgICAgICAgIG5vZGVUeXBlRnJvbVR5cGUsXG4gICAgICAgICAgICBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlLFxuICAgICAgICAgICAgY2F0Y2hpbmdUeXBlLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNpbXVsYXRlRXZlbnQobm9kZSwgZXZlbnQsIG1vY2spIHtcbiAgICAgICAgY29uc3QgbWFwcGVkRXZlbnQgPSBtYXBOYXRpdmVFdmVudE5hbWVzKGV2ZW50KTtcbiAgICAgICAgY29uc3QgZXZlbnRGbiA9IFRlc3RVdGlscy5TaW11bGF0ZVttYXBwZWRFdmVudF07XG4gICAgICAgIGlmICghZXZlbnRGbikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlYWN0V3JhcHBlcjo6c2ltdWxhdGUoKSBldmVudCAnJHtldmVudH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcEFjdCgoKSA9PiB7XG4gICAgICAgICAgZXZlbnRGbihhZGFwdGVyLm5vZGVUb0hvc3ROb2RlKG5vZGUpLCBtb2NrKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9LFxuICAgICAgZ2V0V3JhcHBpbmdDb21wb25lbnRSZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgIC4uLmdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlcih7XG4gICAgICAgICAgICB0b1RyZWU6IChpbnN0KSA9PiB0b1RyZWUoaW5zdC5fcmVhY3RJbnRlcm5hbHMpLFxuICAgICAgICAgICAgZ2V0TW91bnRXcmFwcGVySW5zdGFuY2U6ICgpID0+IGluc3RhbmNlLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyYXBJbnZva2U6IHdyYXBBY3QsXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZVNoYWxsb3dSZW5kZXJlcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcztcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcbiAgICBjb25zdCB7IHN1c3BlbnNlRmFsbGJhY2sgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzdXNwZW5zZUZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc3VzcGVuc2VGYWxsYmFjayAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2BvcHRpb25zLnN1c3BlbnNlRmFsbGJhY2tgIHNob3VsZCBiZSBib29sZWFuIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBsZXQgaXNET00gPSBmYWxzZTtcbiAgICBsZXQgY2FjaGVkTm9kZSA9IG51bGw7XG5cbiAgICBsZXQgbGFzdENvbXBvbmVudCA9IG51bGw7XG4gICAgbGV0IHdyYXBwZWRDb21wb25lbnQgPSBudWxsO1xuICAgIGNvbnN0IHNlbnRpbmVsID0ge307XG5cbiAgICAvLyB3cmFwIG1lbW8gY29tcG9uZW50cyB3aXRoIGEgUHVyZUNvbXBvbmVudCwgb3IgYSBjbGFzcyBjb21wb25lbnQgd2l0aCBzQ1VcbiAgICBjb25zdCB3cmFwUHVyZUNvbXBvbmVudCA9IChDb21wb25lbnQsIGNvbXBhcmUpID0+IHtcbiAgICAgIGlmIChsYXN0Q29tcG9uZW50ICE9PSBDb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGVmdWwoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHdyYXBwZWRDb21wb25lbnQgPSBjbGFzcyBleHRlbmRzIENvbXBvbmVudCB7fTtcbiAgICAgICAgICBpZiAoY29tcGFyZSkge1xuICAgICAgICAgICAgd3JhcHBlZENvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gKG5leHRQcm9wcykgPT5cbiAgICAgICAgICAgICAgIWNvbXBhcmUodGhpcy5wcm9wcywgbmV4dFByb3BzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlZENvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgbWVtb2l6ZWQgPSBzZW50aW5lbDtcbiAgICAgICAgICBsZXQgcHJldlByb3BzO1xuICAgICAgICAgIHdyYXBwZWRDb21wb25lbnQgPSBmdW5jdGlvbiB3cmFwcGVkQ29tcG9uZW50Rm4ocHJvcHMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9XG4gICAgICAgICAgICAgIG1lbW9pemVkID09PSBzZW50aW5lbCB8fFxuICAgICAgICAgICAgICAoY29tcGFyZSA/ICFjb21wYXJlKHByZXZQcm9wcywgcHJvcHMpIDogIXNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIHByb3BzKSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgIG1lbW9pemVkID0gQ29tcG9uZW50KHsgLi4uQ29tcG9uZW50LmRlZmF1bHRQcm9wcywgLi4ucHJvcHMgfSwgLi4uYXJncyk7XG4gICAgICAgICAgICAgIHByZXZQcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih3cmFwcGVkQ29tcG9uZW50LCBDb21wb25lbnQsIHtcbiAgICAgICAgICBkaXNwbGF5TmFtZTogYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZSh7IHR5cGU6IENvbXBvbmVudCB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlZENvbXBvbmVudDtcbiAgICB9O1xuXG4gICAgLy8gV3JhcCBmdW5jdGlvbmFsIGNvbXBvbmVudHMgb24gdmVyc2lvbnMgcHJpb3IgdG8gMTYuNSxcbiAgICAvLyB0byBhdm9pZCBpbmFkdmVydGVudGx5IHBhc3MgYSBgdGhpc2AgaW5zdGFuY2UgdG8gaXQuXG4gICAgY29uc3Qgd3JhcEZ1bmN0aW9uYWxDb21wb25lbnQgPSAoQ29tcG9uZW50KSA9PiB7XG4gICAgICBpZiAoaGFzKENvbXBvbmVudCwgJ2RlZmF1bHRQcm9wcycpKSB7XG4gICAgICAgIGlmIChsYXN0Q29tcG9uZW50ICE9PSBDb21wb25lbnQpIHtcbiAgICAgICAgICB3cmFwcGVkQ29tcG9uZW50ID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIChwcm9wcywgLi4uYXJncykgPT4gQ29tcG9uZW50KHsgLi4uQ29tcG9uZW50LmRlZmF1bHRQcm9wcywgLi4ucHJvcHMgfSwgLi4uYXJncyksXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICB7IGRpc3BsYXlOYW1lOiBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlKHsgdHlwZTogQ29tcG9uZW50IH0pIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsYXN0Q29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwcGVkQ29tcG9uZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIH07XG5cbiAgICBjb25zdCByZW5kZXJFbGVtZW50ID0gKGVsQ29uZmlnLCAuLi5yZXN0KSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnKioqKioqKioqKioqKioqKiByZW5kZXJFbGVtZW50Jyk7XG4gICAgICBjb25zdCByZW5kZXJlZEVsID0gcmVuZGVyZXIucmVuZGVyKGVsQ29uZmlnLCAuLi5yZXN0KTtcblxuICAgICAgY29uc3QgdHlwZUlzRXhpc3RlZCA9ICEhKHJlbmRlcmVkRWwgJiYgcmVuZGVyZWRFbC50eXBlKTtcbiAgICAgIGlmICh0eXBlSXNFeGlzdGVkKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZEVsID0gY2hlY2tJc1N1c3BlbnNlQW5kQ2xvbmVFbGVtZW50KHJlbmRlcmVkRWwsIHsgc3VzcGVuc2VGYWxsYmFjayB9KTtcblxuICAgICAgICBjb25zdCBlbGVtZW50SXNDaGFuZ2VkID0gY2xvbmVkRWwudHlwZSAhPT0gcmVuZGVyZWRFbC50eXBlO1xuICAgICAgICBpZiAoZWxlbWVudElzQ2hhbmdlZCkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJlci5yZW5kZXIoeyAuLi5lbENvbmZpZywgdHlwZTogY2xvbmVkRWwudHlwZSB9LCAuLi5yZXN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVuZGVyZWRFbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgdW5tYXNrZWRDb250ZXh0LCB7IHByb3ZpZGVyVmFsdWVzID0gbmV3IE1hcCgpIH0gPSB7fSkge1xuICAgICAgICBjYWNoZWROb2RlID0gZWw7XG4gICAgICAgIGlmICh0eXBlb2YgZWwudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpc0RPTSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0UHJvdmlkZXIoZWwpKSB7XG4gICAgICAgICAgcHJvdmlkZXJWYWx1ZXMuc2V0KGVsLnR5cGUsIGVsLnByb3BzLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBNb2NrUHJvdmlkZXIgPSBPYmplY3QuYXNzaWduKChwcm9wcykgPT4gcHJvcHMuY2hpbGRyZW4sIGVsLnR5cGUpO1xuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlckVsZW1lbnQoeyAuLi5lbCwgdHlwZTogTW9ja1Byb3ZpZGVyIH0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NvbnRleHRDb25zdW1lcihlbCkpIHtcbiAgICAgICAgICBjb25zdCBQcm92aWRlciA9IGFkYXB0ZXIuZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIoZWwudHlwZSk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlclZhbHVlcy5oYXMoUHJvdmlkZXIpXG4gICAgICAgICAgICA/IHByb3ZpZGVyVmFsdWVzLmdldChQcm92aWRlcilcbiAgICAgICAgICAgIDogZ2V0UHJvdmlkZXJEZWZhdWx0VmFsdWUoUHJvdmlkZXIpO1xuICAgICAgICAgIGNvbnN0IE1vY2tDb25zdW1lciA9IE9iamVjdC5hc3NpZ24oKHByb3BzKSA9PiBwcm9wcy5jaGlsZHJlbih2YWx1ZSksIGVsLnR5cGUpO1xuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlckVsZW1lbnQoeyAuLi5lbCwgdHlwZTogTW9ja0NvbnN1bWVyIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0RPTSA9IGZhbHNlO1xuICAgICAgICAgIGxldCByZW5kZXJlZEVsID0gZWw7XG4gICAgICAgICAgaWYgKGlzTGF6eShyZW5kZXJlZEVsKSkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdgUmVhY3QubGF6eWAgaXMgbm90IHN1cHBvcnRlZCBieSBzaGFsbG93IHJlbmRlcmluZy4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW5kZXJlZEVsID0gY2hlY2tJc1N1c3BlbnNlQW5kQ2xvbmVFbGVtZW50KHJlbmRlcmVkRWwsIHsgc3VzcGVuc2VGYWxsYmFjayB9KTtcbiAgICAgICAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCB9ID0gcmVuZGVyZWRFbDtcblxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KENvbXBvbmVudC5jb250ZXh0VHlwZXMsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoaXNNZW1vKGVsLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGU6IElubmVyQ29tcCwgY29tcGFyZSB9ID0gZWwudHlwZTtcblxuICAgICAgICAgICAgcmV0dXJuIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT5cbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudCh7IC4uLmVsLCB0eXBlOiB3cmFwUHVyZUNvbXBvbmVudChJbm5lckNvbXAsIGNvbXBhcmUpIH0sIGNvbnRleHQpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpc0NvbXBvbmVudFN0YXRlZnVsID0gaXNTdGF0ZWZ1bChDb21wb25lbnQpO1xuXG4gICAgICAgICAgaWYgKCFpc0NvbXBvbmVudFN0YXRlZnVsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+XG4gICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQoeyAuLi5yZW5kZXJlZEVsLCB0eXBlOiB3cmFwRnVuY3Rpb25hbENvbXBvbmVudChDb21wb25lbnQpIH0sIGNvbnRleHQpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNDb21wb25lbnRTdGF0ZWZ1bCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICByZW5kZXJlci5faW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgZWwucHJvcHMgPT09IHJlbmRlcmVyLl9pbnN0YW5jZS5wcm9wcyAmJlxuICAgICAgICAgICAgICAhc2hhbGxvd0VxdWFsKGNvbnRleHQsIHJlbmRlcmVyLl9pbnN0YW5jZS5jb250ZXh0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgcmVzdG9yZSB9ID0gc3B5TWV0aG9kKFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgICAgICdfdXBkYXRlQ2xhc3NDb21wb25lbnQnLFxuICAgICAgICAgICAgICAgIChvcmlnaW5hbE1ldGhvZCkgPT5cbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF91cGRhdGVDbGFzc0NvbXBvbmVudCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHJlbmRlcmVyLl9pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkUHJvcHMgPSB7IC4uLnByb3BzIH07XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLl9pbnN0YW5jZS5wcm9wcyA9IGNsb25lZFByb3BzO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsTWV0aG9kLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5faW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaXggcmVhY3QgYnVnOyBzZWUgaW1wbGVtZW50YXRpb24gb2YgYGdldEVtcHR5U3RhdGVWYWx1ZWBcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5U3RhdGVWYWx1ZSA9IGdldEVtcHR5U3RhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGVtcHR5U3RhdGVWYWx1ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgJ3N0YXRlJywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGVtcHR5U3RhdGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YXRlJywge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4gcmVuZGVyRWxlbWVudChyZW5kZXJlZEVsLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICByZW5kZXJlci51bm1vdW50KCk7XG4gICAgICB9LFxuICAgICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgaWYgKGlzRE9NKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRUb1RyZWUoY2FjaGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyT3V0cHV0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZVR5cGU6IG5vZGVUeXBlRnJvbVR5cGUoY2FjaGVkTm9kZS50eXBlKSxcbiAgICAgICAgICB0eXBlOiBjYWNoZWROb2RlLnR5cGUsXG4gICAgICAgICAgcHJvcHM6IGNhY2hlZE5vZGUucHJvcHMsXG4gICAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChjYWNoZWROb2RlLmtleSksXG4gICAgICAgICAgcmVmOiBjYWNoZWROb2RlLnJlZixcbiAgICAgICAgICBpbnN0YW5jZTogcmVuZGVyZXIuX2luc3RhbmNlLFxuICAgICAgICAgIHJlbmRlcmVkOiBBcnJheS5pc0FycmF5KG91dHB1dClcbiAgICAgICAgICAgID8gZmxhdHRlbihvdXRwdXQpLm1hcCgoZWwpID0+IGVsZW1lbnRUb1RyZWUoZWwpKVxuICAgICAgICAgICAgOiBlbGVtZW50VG9UcmVlKG91dHB1dCksXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFcnJvcihub2RlSGllcmFyY2h5LCByb290Tm9kZSwgZXJyb3IpIHtcbiAgICAgICAgc2ltdWxhdGVFcnJvcihcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZW5kZXJlci5faW5zdGFuY2UsXG4gICAgICAgICAgY2FjaGVkTm9kZSxcbiAgICAgICAgICBub2RlSGllcmFyY2h5LmNvbmNhdChjYWNoZWROb2RlKSxcbiAgICAgICAgICBub2RlVHlwZUZyb21UeXBlLFxuICAgICAgICAgIGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUsXG4gICAgICAgICAgY2FjaGVkTm9kZS50eXBlLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNpbXVsYXRlRXZlbnQobm9kZSwgZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG5vZGUucHJvcHNbcHJvcEZyb21FdmVudChldmVudCldO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETyhsbXIpOiBjcmVhdGUvdXNlIHN5bnRoZXRpYyBldmVudHNcbiAgICAgICAgICAgIC8vIFRPRE8obG1yKTogZW11bGF0ZSBSZWFjdCdzIGV2ZW50IHByb3BhZ2F0aW9uXG4gICAgICAgICAgICBoYW5kbGVyKC4uLmFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9LFxuICAgICAgY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBoaWVyYXJjaHkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgZGlzcGxheU5hbWVPZk5vZGUoY2FjaGVkTm9kZSksICgpID0+XG4gICAgICAgICAgZ2V0Q29tcG9uZW50U3RhY2soaGllcmFyY2h5LmNvbmNhdChbY2FjaGVkTm9kZV0pKSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZVN0cmluZ1JlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICBpZiAoaGFzKG9wdGlvbnMsICdzdXNwZW5zZUZhbGxiYWNrJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdgc3VzcGVuc2VGYWxsYmFja2Agc2hvdWxkIG5vdCBiZSBzcGVjaWZpZWQgaW4gb3B0aW9ucyBvZiBzdHJpbmcgcmVuZGVyZXInLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgY29udGV4dCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jb250ZXh0ICYmIChlbC50eXBlLmNvbnRleHRUeXBlcyB8fCBvcHRpb25zLmNoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgLi4uKGVsLnR5cGUuY29udGV4dFR5cGVzIHx8IHt9KSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBDb250ZXh0V3JhcHBlciA9IGNyZWF0ZVJlbmRlcldyYXBwZXIoZWwsIGNvbnRleHQsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXAoUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0V3JhcHBlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY01hcmt1cChlbCk7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvLyBQcm92aWRlZCBhIGJhZyBvZiBvcHRpb25zLCByZXR1cm4gYW4gYEVuenltZVJlbmRlcmVyYC4gU29tZSBvcHRpb25zIGNhbiBiZSBpbXBsZW1lbnRhdGlvblxuICAvLyBzcGVjaWZpYywgbGlrZSBgYXR0YWNoYCBldGMuIGZvciBSZWFjdCwgYnV0IG5vdCBwYXJ0IG9mIHRoaXMgaW50ZXJmYWNlIGV4cGxpY2l0bHkuXG4gIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMubW9kZSkge1xuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLk1PVU5UOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVNb3VudFJlbmRlcmVyKG9wdGlvbnMpO1xuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLlNIQUxMT1c6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNoYWxsb3dSZW5kZXJlcihvcHRpb25zKTtcbiAgICAgIGNhc2UgRW56eW1lQWRhcHRlci5NT0RFUy5TVFJJTkc6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0cmluZ1JlbmRlcmVyKG9wdGlvbnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IFVucmVjb2duaXplZCBtb2RlOiAke29wdGlvbnMubW9kZX1gKTtcbiAgICB9XG4gIH1cblxuICB3cmFwKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gd3JhcChlbGVtZW50KTtcbiAgfVxuXG4gIC8vIGNvbnZlcnRzIGFuIFJTVE5vZGUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgSlNYIFByYWdtYSBFbGVtZW50LiBUaGlzIHdpbGwgYmUgbmVlZGVkXG4gIC8vIGluIG9yZGVyIHRvIGltcGxlbWVudCB0aGUgYFdyYXBwZXIubW91bnQoKWAgYW5kIGBXcmFwcGVyLnNoYWxsb3coKWAgbWV0aG9kcywgYnV0IHNob3VsZFxuICAvLyBiZSBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkIGZvciBwZW9wbGUgdG8gaW1wbGVtZW50LlxuICBub2RlVG9FbGVtZW50KG5vZGUpIHtcbiAgICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB7IHR5cGUgfSA9IG5vZGU7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQodW5tZW1vVHlwZSh0eXBlKSwgcHJvcHNXaXRoS2V5c0FuZFJlZihub2RlKSk7XG4gIH1cblxuICBtYXRjaGVzRWxlbWVudFR5cGUobm9kZSwgbWF0Y2hpbmdUeXBlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlIH0gPSBub2RlO1xuICAgIHJldHVybiB1bm1lbW9UeXBlKHR5cGUpID09PSB1bm1lbW9UeXBlKG1hdGNoaW5nVHlwZSk7XG4gIH1cblxuICBlbGVtZW50VG9Ob2RlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudFRvVHJlZShlbGVtZW50KTtcbiAgfVxuXG4gIG5vZGVUb0hvc3ROb2RlKG5vZGUsIHN1cHBvcnRzQXJyYXkgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5vZGVzID0gbm9kZVRvSG9zdE5vZGUobm9kZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpICYmICFzdXBwb3J0c0FycmF5KSB7XG4gICAgICAvLyBnZXQgdGhlIGZpcnN0IG5vbi1udWxsIG5vZGVcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoQm9vbGVhbilbMF07XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGRpc3BsYXlOYW1lT2ZOb2RlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHsgdHlwZSwgJCR0eXBlb2YgfSA9IG5vZGU7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXM7XG5cbiAgICBjb25zdCBub2RlVHlwZSA9IHR5cGUgfHwgJCR0eXBlb2Y7XG5cbiAgICAvLyBuZXdlciBub2RlIHR5cGVzIG1heSBiZSB1bmRlZmluZWQsIHNvIG9ubHkgdGVzdCBpZiB0aGUgbm9kZVR5cGUgZXhpc3RzXG4gICAgaWYgKG5vZGVUeXBlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgQ29uY3VycmVudE1vZGUgfHwgTmFOOlxuICAgICAgICAgIHJldHVybiAnQ29uY3VycmVudE1vZGUnO1xuICAgICAgICBjYXNlIEZyYWdtZW50IHx8IE5hTjpcbiAgICAgICAgICByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICAgICAgY2FzZSBTdHJpY3RNb2RlIHx8IE5hTjpcbiAgICAgICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgICAgICBjYXNlIFByb2ZpbGVyIHx8IE5hTjpcbiAgICAgICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcbiAgICAgICAgY2FzZSBQb3J0YWwgfHwgTmFOOlxuICAgICAgICAgIHJldHVybiAnUG9ydGFsJztcbiAgICAgICAgY2FzZSBTdXNwZW5zZSB8fCBOYU46XG4gICAgICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgIGNhc2UgQ29udGV4dENvbnN1bWVyIHx8IE5hTjpcbiAgICAgICAgcmV0dXJuICdDb250ZXh0Q29uc3VtZXInO1xuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXIgfHwgTmFOOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHRQcm92aWRlcic7XG4gICAgICBjYXNlIE1lbW8gfHwgTmFOOiB7XG4gICAgICAgIGNvbnN0IG5vZGVOYW1lID0gZGlzcGxheU5hbWVPZk5vZGUobm9kZSk7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZU5hbWUgPT09ICdzdHJpbmcnID8gbm9kZU5hbWUgOiBgTWVtbygke2FkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUodHlwZSl9KWA7XG4gICAgICB9XG4gICAgICBjYXNlIEZvcndhcmRSZWYgfHwgTmFOOiB7XG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUoeyB0eXBlOiB0eXBlLnJlbmRlciB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBgRm9yd2FyZFJlZigke25hbWV9KWAgOiAnRm9yd2FyZFJlZic7XG4gICAgICB9XG4gICAgICBjYXNlIExhenkgfHwgTmFOOiB7XG4gICAgICAgIHJldHVybiAnbGF6eSc7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGlzcGxheU5hbWVPZk5vZGUobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoZWxlbWVudCk7XG4gIH1cblxuICBpc1ZhbGlkRWxlbWVudFR5cGUob2JqZWN0KSB7XG4gICAgcmV0dXJuICEhb2JqZWN0ICYmIGlzVmFsaWRFbGVtZW50VHlwZShvYmplY3QpO1xuICB9XG5cbiAgaXNGcmFnbWVudChmcmFnbWVudCkge1xuICAgIHJldHVybiB0eXBlT2ZOb2RlKGZyYWdtZW50KSA9PT0gRnJhZ21lbnQ7XG4gIH1cblxuICBpc0N1c3RvbUNvbXBvbmVudCh0eXBlKSB7XG4gICAgY29uc3QgZmFrZUVsZW1lbnQgPSBtYWtlRmFrZUVsZW1lbnQodHlwZSk7XG4gICAgcmV0dXJuIChcbiAgICAgICEhdHlwZSAmJlxuICAgICAgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzRm9yd2FyZFJlZihmYWtlRWxlbWVudCkgfHxcbiAgICAgICAgaXNDb250ZXh0UHJvdmlkZXIoZmFrZUVsZW1lbnQpIHx8XG4gICAgICAgIGlzQ29udGV4dENvbnN1bWVyKGZha2VFbGVtZW50KSB8fFxuICAgICAgICBpc1N1c3BlbnNlKGZha2VFbGVtZW50KSlcbiAgICApO1xuICB9XG5cbiAgaXNDb250ZXh0Q29uc3VtZXIodHlwZSkge1xuICAgIHJldHVybiAhIXR5cGUgJiYgaXNDb250ZXh0Q29uc3VtZXIobWFrZUZha2VFbGVtZW50KHR5cGUpKTtcbiAgfVxuXG4gIGlzQ3VzdG9tQ29tcG9uZW50RWxlbWVudChpbnN0KSB7XG4gICAgaWYgKCFpbnN0IHx8ICF0aGlzLmlzVmFsaWRFbGVtZW50KGluc3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzQ3VzdG9tQ29tcG9uZW50KGluc3QudHlwZSk7XG4gIH1cblxuICBnZXRQcm92aWRlckZyb21Db25zdW1lcihDb25zdW1lcikge1xuICAgIC8vIFJlYWN0IHN0b3JlcyByZWZlcmVuY2VzIHRvIHRoZSBQcm92aWRlciBvbiBhIENvbnN1bWVyIGRpZmZlcmVudGx5IGFjcm9zcyB2ZXJzaW9ucy5cbiAgICBpZiAoQ29uc3VtZXIpIHtcbiAgICAgIGxldCBQcm92aWRlcjtcbiAgICAgIGlmIChDb25zdW1lci5fY29udGV4dCkge1xuICAgICAgICAvLyBjaGVjayB0aGlzIGZpcnN0LCB0byBhdm9pZCBhIGRlcHJlY2F0aW9uIHdhcm5pbmdcbiAgICAgICAgKHsgUHJvdmlkZXIgfSA9IENvbnN1bWVyLl9jb250ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoQ29uc3VtZXIuUHJvdmlkZXIpIHtcbiAgICAgICAgKHsgUHJvdmlkZXIgfSA9IENvbnN1bWVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gUHJvdmlkZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignRW56eW1lIEludGVybmFsIEVycm9yOiBjYW7igJl0IGZpZ3VyZSBvdXQgaG93IHRvIGdldCBQcm92aWRlciBmcm9tIENvbnN1bWVyJyk7XG4gIH1cblxuICBjcmVhdGVFbGVtZW50KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gd3JhcEFjdCgoKSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KC4uLmFyZ3MpKTtcbiAgfVxuXG4gIHdyYXBXaXRoV3JhcHBpbmdDb21wb25lbnQobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBSb290RmluZGVyLFxuICAgICAgbm9kZTogd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudChSZWFjdC5jcmVhdGVFbGVtZW50LCBub2RlLCBvcHRpb25zKSxcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFaWdodGVlbkFkYXB0ZXI7XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBcUJBOztBQUNBOztBQUNBOztBQUNBOztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQUVBLFNBQVNBLG9CQUFULENBQThCQyxlQUE5QixFQUErQztFQUM3QyxJQUFNQyxLQUFLLEdBQUcsRUFBZDtFQUNBLElBQUlDLElBQUksR0FBR0YsZUFBWDs7RUFDQSxPQUFPRSxJQUFJLElBQUksSUFB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
//# sourceMappingURL=ReactEighteenAdapter.js.map