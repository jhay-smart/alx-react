"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "RootFinder", {
  enumerable: true,
  get: function get() {
    return _RootFinder["default"];
  }
});
exports.assertDomAvailable = assertDomAvailable;
exports.compareNodeTypeOf = compareNodeTypeOf;
Object.defineProperty(exports, "createMountWrapper", {
  enumerable: true,
  get: function get() {
    return _createMountWrapper["default"];
  }
});
Object.defineProperty(exports, "createRenderWrapper", {
  enumerable: true,
  get: function get() {
    return _createRenderWrapper["default"];
  }
});
exports.displayNameOfNode = displayNameOfNode;
exports.elementToTree = elementToTree;
exports.ensureKeyOrUndefined = ensureKeyOrUndefined;
exports.fakeDynamicImport = fakeDynamicImport;
exports.findElement = findElement;
exports.flatten = flatten;
exports.getComponentStack = getComponentStack;
exports.getMaskedContext = getMaskedContext;
exports.getNodeFromRootFinder = getNodeFromRootFinder;
exports.getPublicRootInstance = getPublicRootInstance;
exports.getWrappingComponentMountRenderer = getWrappingComponentMountRenderer;
exports.isArrayLike = isArrayLike;
exports.mapNativeEventNames = mapNativeEventNames;
exports.nodeTypeFromType = nodeTypeFromType;
exports.propFromEvent = propFromEvent;
exports.propsWithKeysAndRef = propsWithKeysAndRef;
exports.simulateError = simulateError;
exports.spyMethod = spyMethod;
exports.spyProperty = spyProperty;
exports.withSetStateAllowed = withSetStateAllowed;
Object.defineProperty(exports, "wrap", {
  enumerable: true,
  get: function get() {
    return _wrapWithSimpleWrapper["default"];
  }
});
exports.wrapWithWrappingComponent = wrapWithWrappingComponent;

var _functionPrototype = _interopRequireDefault(require("function.prototype.name"));

var _object = _interopRequireDefault(require("object.fromentries"));

var _has = _interopRequireDefault(require("has"));

var _createMountWrapper = _interopRequireDefault(require("./createMountWrapper"));

var _createRenderWrapper = _interopRequireDefault(require("./createRenderWrapper"));

var _wrapWithSimpleWrapper = _interopRequireDefault(require("./wrapWithSimpleWrapper"));

var _RootFinder = _interopRequireDefault(require("./RootFinder"));

var _tagCodes = require("./tagCodes");

var _reactDom = require("react-dom");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function mapNativeEventNames(event) {
  var nativeToReactEventMap = {
    compositionend: 'compositionEnd',
    compositionstart: 'compositionStart',
    compositionupdate: 'compositionUpdate',
    keydown: 'keyDown',
    keyup: 'keyUp',
    keypress: 'keyPress',
    contextmenu: 'contextMenu',
    dblclick: 'doubleClick',
    doubleclick: 'doubleClick',
    // kept for legacy. TODO: remove with next major.
    dragend: 'dragEnd',
    dragenter: 'dragEnter',
    dragexist: 'dragExit',
    dragleave: 'dragLeave',
    dragover: 'dragOver',
    dragstart: 'dragStart',
    mousedown: 'mouseDown',
    mousemove: 'mouseMove',
    mouseout: 'mouseOut',
    mouseover: 'mouseOver',
    mouseup: 'mouseUp',
    touchcancel: 'touchCancel',
    touchend: 'touchEnd',
    touchmove: 'touchMove',
    touchstart: 'touchStart',
    canplay: 'canPlay',
    canplaythrough: 'canPlayThrough',
    durationchange: 'durationChange',
    loadeddata: 'loadedData',
    loadedmetadata: 'loadedMetadata',
    loadstart: 'loadStart',
    ratechange: 'rateChange',
    timeupdate: 'timeUpdate',
    volumechange: 'volumeChange',
    beforeinput: 'beforeInput',
    mouseenter: 'mouseEnter',
    mouseleave: 'mouseLeave',
    transitionend: 'transitionEnd',
    animationstart: 'animationStart',
    animationiteration: 'animationIteration',
    animationend: 'animationEnd',
    pointerdown: 'pointerDown',
    pointermove: 'pointerMove',
    pointerup: 'pointerUp',
    pointercancel: 'pointerCancel',
    gotpointercapture: 'gotPointerCapture',
    lostpointercapture: 'lostPointerCapture',
    pointerenter: 'pointerEnter',
    pointerleave: 'pointerLeave',
    pointerover: 'pointerOver',
    pointerout: 'pointerOut',
    auxclick: 'auxClick'
  };
  return nativeToReactEventMap[event] || event;
} // 'click' => 'onClick'
// 'mouseEnter' => 'onMouseEnter'


function propFromEvent(event) {
  var nativeEvent = mapNativeEventNames(event);
  return "on".concat(nativeEvent[0].toUpperCase()).concat(nativeEvent.slice(1));
}

function withSetStateAllowed(fn) {
  // NOTE(lmr):
  // this is currently here to circumvent a React bug where `setState()` is
  // not allowed without global being defined.
  var cleanup = false;

  if (typeof global.document === 'undefined') {
    cleanup = true;
    global.document = {};
  }

  var result = fn();

  if (cleanup) {
    // This works around a bug in node/jest in that developers aren't able to
    // delete things from global when running in a node vm.
    global.document = undefined;
    delete global.document;
  }

  return result;
}

function assertDomAvailable(feature) {
  if (!global || !global.document || !global.document.createElement) {
    throw new Error("Enzyme's ".concat(feature, " expects a DOM environment to be loaded, but found none"));
  }
}

function displayNameOfNode(node) {
  if (!node) return null;
  var type = node.type;
  if (!type) return null;
  return type.displayName || (typeof type === 'function' ? (0, _functionPrototype["default"])(type) : type.name || type);
}

function nodeTypeFromType(type) {
  if (typeof type === 'string') {
    return 'host';
  }

  if (type && type.prototype && type.prototype.isReactComponent) {
    return 'class';
  }

  return 'function';
}

function getIteratorFn(obj) {
  var iteratorFn = obj && (typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' && obj[Symbol.iterator] || obj['@@iterator']);

  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }

  return undefined;
}

function isIterable(obj) {
  return !!getIteratorFn(obj);
}

function isArrayLike(obj) {
  return Array.isArray(obj) || typeof obj !== 'string' && isIterable(obj);
}

function flatten(arrs) {
  // optimize for the most common case
  if (Array.isArray(arrs)) {
    return arrs.reduce(function (flatArrs, item) {
      return flatArrs.concat(isArrayLike(item) ? flatten(item) : item);
    }, []);
  } // fallback for arbitrary iterable children


  var flatArrs = [];
  var iteratorFn = getIteratorFn(arrs);
  var iterator = iteratorFn.call(arrs);
  var step = iterator.next();

  while (!step.done) {
    var item = step.value;
    var flatItem = void 0;

    if (isArrayLike(item)) {
      flatItem = flatten(item);
    } else {
      flatItem = item;
    }

    flatArrs = flatArrs.concat(flatItem);
    step = iterator.next();
  }

  return flatArrs;
}

function ensureKeyOrUndefined(key) {
  return key || (key === '' ? '' : undefined);
}

function elementToTree(el) {
  var recurse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : elementToTree;

  if (typeof recurse !== 'function' && arguments.length === 3) {
    // special case for backwards compat for `.map(elementToTree)`
    recurse = elementToTree;
  }

  if (el === null || _typeof(el) !== 'object' || !('type' in el)) {
    return el;
  }

  var type = el.type,
      props = el.props,
      key = el.key,
      ref = el.ref;
  var children = props.children;
  var rendered = null;

  if (isArrayLike(children)) {
    rendered = flatten(children).map(function (x) {
      return recurse(x);
    });
  } else if (typeof children !== 'undefined') {
    rendered = recurse(children);
  }

  var nodeType = nodeTypeFromType(type);

  if (nodeType === 'host' && props.dangerouslySetInnerHTML) {
    if (props.children != null) {
      var error = new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');
      error.name = 'Invariant Violation';
      throw error;
    }
  }

  return {
    nodeType: nodeType,
    type: type,
    props: props,
    key: ensureKeyOrUndefined(key),
    ref: ref,
    instance: null,
    rendered: rendered
  };
}

function mapFind(arraylike, mapper, finder) {
  var found;
  var isFound = Array.prototype.find.call(arraylike, function (item) {
    found = mapper(item);
    return finder(found);
  });
  return isFound ? found : undefined;
}

function findElement(el, predicate) {
  if (el === null || _typeof(el) !== 'object' || !('type' in el)) {
    return undefined;
  }

  if (predicate(el)) {
    return el;
  }

  var rendered = el.rendered;

  if (isArrayLike(rendered)) {
    return mapFind(rendered, function (x) {
      return findElement(x, predicate);
    }, function (x) {
      return typeof x !== 'undefined';
    });
  }

  return findElement(rendered, predicate);
}

function propsWithKeysAndRef(node) {
  if (node.ref !== null || node.key !== null) {
    return _objectSpread(_objectSpread({}, node.props), {}, {
      key: node.key,
      ref: node.ref
    });
  }

  return node.props;
}

function getComponentStack(hierarchy) {
  var getNodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : nodeTypeFromType;
  var getDisplayName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : displayNameOfNode;
  var tuples = hierarchy.filter(function (node) {
    return node.type !== _RootFinder["default"];
  }).map(function (x) {
    return [getNodeType(x.type), getDisplayName(x)];
  }).concat([['class', 'WrapperComponent']]);
  return tuples.map(function (_ref, i, arr) {
    var _ref2 = _slicedToArray(_ref, 2),
        name = _ref2[1];

    var _ref3 = arr.slice(i + 1).find(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
          nodeType = _ref6[0];

      return nodeType !== 'host';
    }) || [],
        _ref4 = _slicedToArray(_ref3, 2),
        closestComponent = _ref4[1];

    return "\n    in ".concat(name).concat(closestComponent ? " (created by ".concat(closestComponent, ")") : '');
  }).join('');
}

function simulateError(error, catchingInstance, rootNode, // TODO: remove `rootNode` next semver-major
hierarchy) {
  var getNodeType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : nodeTypeFromType;
  var getDisplayName = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : displayNameOfNode;
  var catchingType = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
  var instance = catchingInstance || {};
  var componentDidCatch = instance.componentDidCatch;
  var getDerivedStateFromError = catchingType.getDerivedStateFromError;

  if (!componentDidCatch && !getDerivedStateFromError) {
    throw error;
  }

  if (getDerivedStateFromError) {
    var stateUpdate = getDerivedStateFromError.call(catchingType, error);
    (0, _reactDom.flushSync)(function () {
      instance.setState(stateUpdate);
    });
  }

  if (componentDidCatch) {
    var componentStack = getComponentStack(hierarchy, getNodeType, getDisplayName);
    componentDidCatch.call(instance, error, {
      componentStack: componentStack
    });
  }
}

function getMaskedContext(contextTypes, unmaskedContext) {
  if (!contextTypes || !unmaskedContext) {
    return {};
  }

  return (0, _object["default"])(Object.keys(contextTypes).map(function (key) {
    return [key, unmaskedContext[key]];
  }));
}

function getNodeFromRootFinder(isCustomComponent, tree, options) {
  if (!isCustomComponent(options.wrappingComponent)) {
    return tree.rendered;
  }

  var rootFinder = findElement(tree, function (node) {
    return node.type === _RootFinder["default"];
  });

  if (!rootFinder) {
    throw new Error('`wrappingComponent` must render its children!');
  }

  return rootFinder.rendered;
}

function wrapWithWrappingComponent(createElement, node, options) {
  var wrappingComponent = options.wrappingComponent,
      wrappingComponentProps = options.wrappingComponentProps;

  if (!wrappingComponent) {
    return node;
  }

  return createElement(wrappingComponent, wrappingComponentProps, createElement(_RootFinder["default"], null, node));
}

function getWrappingComponentMountRenderer(_ref7) {
  var toTree = _ref7.toTree,
      getMountWrapperInstance = _ref7.getMountWrapperInstance;
  return {
    getNode: function getNode() {
      var instance = getMountWrapperInstance();
      return instance ? toTree(instance).rendered : null;
    },
    render: function render(el, context, callback) {
      var instance = getMountWrapperInstance();

      if (!instance) {
        throw new Error('The wrapping component may not be updated if the root is unmounted.');
      }

      return instance.setWrappingComponentProps(el.props, callback);
    }
  };
}

function fakeDynamicImport(moduleToImport) {
  return Promise.resolve({
    "default": moduleToImport
  });
}

function compareNodeTypeOf(node, matchingTypeOf) {
  if (!node) {
    return false;
  }

  return node.$$typeof === matchingTypeOf;
} // TODO: when enzyme v3.12.0 is required, delete this


function spyMethod(instance, methodName) {
  var getStub = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
  var lastReturnValue;
  var originalMethod = instance[methodName];
  var hasOwn = (0, _has["default"])(instance, methodName);
  var descriptor;

  if (hasOwn) {
    descriptor = Object.getOwnPropertyDescriptor(instance, methodName);
  }

  Object.defineProperty(instance, methodName, {
    configurable: true,
    enumerable: !descriptor || !!descriptor.enumerable,
    value: getStub(originalMethod) || function spied() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var result = originalMethod.apply(this, args);
      lastReturnValue = result;
      return result;
    }
  });
  return {
    restore: function restore() {
      if (hasOwn) {
        if (descriptor) {
          Object.defineProperty(instance, methodName, descriptor);
        } else {
          instance[methodName] = originalMethod;
        }
      } else {
        delete instance[methodName];
      }
    },
    getLastReturnValue: function getLastReturnValue() {
      return lastReturnValue;
    }
  };
} // TODO: when enzyme v3.12.0 is required, delete this


function spyProperty(instance, propertyName) {
  var handlers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var originalValue = instance[propertyName];
  var hasOwn = (0, _has["default"])(instance, propertyName);
  var descriptor;

  if (hasOwn) {
    descriptor = Object.getOwnPropertyDescriptor(instance, propertyName);
  }

  var _wasAssigned = false;
  var holder = originalValue;
  var getV = handlers.get ? function () {
    var value = descriptor && descriptor.get ? descriptor.get.call(instance) : holder;
    return handlers.get.call(instance, value);
  } : function () {
    return holder;
  };
  var set = handlers.set ? function (newValue) {
    _wasAssigned = true;
    var handlerNewValue = handlers.set.call(instance, holder, newValue);
    holder = handlerNewValue;

    if (descriptor && descriptor.set) {
      descriptor.set.call(instance, holder);
    }
  } : function (v) {
    _wasAssigned = true;
    holder = v;
  };
  Object.defineProperty(instance, propertyName, {
    configurable: true,
    enumerable: !descriptor || !!descriptor.enumerable,
    get: getV,
    set: set
  });
  return {
    restore: function restore() {
      if (hasOwn) {
        if (descriptor) {
          Object.defineProperty(instance, propertyName, descriptor);
        } else {
          instance[propertyName] = holder;
        }
      } else {
        delete instance[propertyName];
      }
    },
    wasAssigned: function wasAssigned() {
      return _wasAssigned;
    }
  };
}

function getPublicRootInstance(container) {
  var containerFiber = container._internalRoot.current;

  if (!containerFiber.child) {
    return null;
  }

  switch (containerFiber.child.tag) {
    case _tagCodes.HostComponent:
      return getPublicInstance(containerFiber.child.stateNode);

    default:
      return containerFiber.child.stateNode;
  }
}

function getPublicInstance(instance) {
  return instance;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtYXBOYXRpdmVFdmVudE5hbWVzIiwiZXZlbnQiLCJuYXRpdmVUb1JlYWN0RXZlbnRNYXAiLCJjb21wb3NpdGlvbmVuZCIsImNvbXBvc2l0aW9uc3RhcnQiLCJjb21wb3NpdGlvbnVwZGF0ZSIsImtleWRvd24iLCJrZXl1cCIsImtleXByZXNzIiwiY29udGV4dG1lbnUiLCJkYmxjbGljayIsImRvdWJsZWNsaWNrIiwiZHJhZ2VuZCIsImRyYWdlbnRlciIsImRyYWdleGlzdCIsImRyYWdsZWF2ZSIsImRyYWdvdmVyIiwiZHJhZ3N0YXJ0IiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2VvdXQiLCJtb3VzZW92ZXIiLCJtb3VzZXVwIiwidG91Y2hjYW5jZWwiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoc3RhcnQiLCJjYW5wbGF5IiwiY2FucGxheXRocm91Z2giLCJkdXJhdGlvbmNoYW5nZSIsImxvYWRlZGRhdGEiLCJsb2FkZWRtZXRhZGF0YSIsImxvYWRzdGFydCIsInJhdGVjaGFuZ2UiLCJ0aW1ldXBkYXRlIiwidm9sdW1lY2hhbmdlIiwiYmVmb3JlaW5wdXQiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsInRyYW5zaXRpb25lbmQiLCJhbmltYXRpb25zdGFydCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbmVuZCIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVyY2FuY2VsIiwiZ290cG9pbnRlcmNhcHR1cmUiLCJsb3N0cG9pbnRlcmNhcHR1cmUiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJwb2ludGVyb3ZlciIsInBvaW50ZXJvdXQiLCJhdXhjbGljayIsInByb3BGcm9tRXZlbnQiLCJuYXRpdmVFdmVudCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ3aXRoU2V0U3RhdGVBbGxvd2VkIiwiZm4iLCJjbGVhbnVwIiwiZ2xvYmFsIiwiZG9jdW1lbnQiLCJyZXN1bHQiLCJ1bmRlZmluZWQiLCJhc3NlcnREb21BdmFpbGFibGUiLCJmZWF0dXJlIiwiY3JlYXRlRWxlbWVudCIsIkVycm9yIiwiZGlzcGxheU5hbWVPZk5vZGUiLCJub2RlIiwidHlwZSIsImRpc3BsYXlOYW1lIiwiZnVuY3Rpb25OYW1lIiwibmFtZSIsIm5vZGVUeXBlRnJvbVR5cGUiLCJwcm90b3R5cGUiLCJpc1JlYWN0Q29tcG9uZW50IiwiZ2V0SXRlcmF0b3JGbiIsIm9iaiIsIml0ZXJhdG9yRm4iLCJTeW1ib2wiLCJpdGVyYXRvciIsImlzSXRlcmFibGUiLCJpc0FycmF5TGlrZSIsIkFycmF5IiwiaXNBcnJheSIsImZsYXR0ZW4iLCJhcnJzIiwicmVkdWNlIiwiZmxhdEFycnMiLCJpdGVtIiwiY29uY2F0IiwiY2FsbCIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbHVlIiwiZmxhdEl0ZW0iLCJlbnN1cmVLZXlPclVuZGVmaW5lZCIsImtleSIsImVsZW1lbnRUb1RyZWUiLCJlbCIsInJlY3Vyc2UiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwcm9wcyIsInJlZiIsImNoaWxkcmVuIiwicmVuZGVyZWQiLCJtYXAiLCJ4Iiwibm9kZVR5cGUiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImVycm9yIiwiaW5zdGFuY2UiLCJtYXBGaW5kIiwiYXJyYXlsaWtlIiwibWFwcGVyIiwiZmluZGVyIiwiZm91bmQiLCJpc0ZvdW5kIiwiZmluZCIsImZpbmRFbGVtZW50IiwicHJlZGljYXRlIiwicHJvcHNXaXRoS2V5c0FuZFJlZiIsImdldENvbXBvbmVudFN0YWNrIiwiaGllcmFyY2h5IiwiZ2V0Tm9kZVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsInR1cGxlcyIsImZpbHRlciIsIlJvb3RGaW5kZXIiLCJpIiwiYXJyIiwiY2xvc2VzdENvbXBvbmVudCIsImpvaW4iLCJzaW11bGF0ZUVycm9yIiwiY2F0Y2hpbmdJbnN0YW5jZSIsInJvb3ROb2RlIiwiY2F0Y2hpbmdUeXBlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJzdGF0ZVVwZGF0ZSIsImZsdXNoU3luYyIsInNldFN0YXRlIiwiY29tcG9uZW50U3RhY2siLCJnZXRNYXNrZWRDb250ZXh0IiwiY29udGV4dFR5cGVzIiwidW5tYXNrZWRDb250ZXh0IiwiZnJvbUVudHJpZXMiLCJPYmplY3QiLCJrZXlzIiwiZ2V0Tm9kZUZyb21Sb290RmluZGVyIiwiaXNDdXN0b21Db21wb25lbnQiLCJ0cmVlIiwib3B0aW9ucyIsIndyYXBwaW5nQ29tcG9uZW50Iiwicm9vdEZpbmRlciIsIndyYXBXaXRoV3JhcHBpbmdDb21wb25lbnQiLCJ3cmFwcGluZ0NvbXBvbmVudFByb3BzIiwiZ2V0V3JhcHBpbmdDb21wb25lbnRNb3VudFJlbmRlcmVyIiwidG9UcmVlIiwiZ2V0TW91bnRXcmFwcGVySW5zdGFuY2UiLCJnZXROb2RlIiwicmVuZGVyIiwiY29udGV4dCIsImNhbGxiYWNrIiwic2V0V3JhcHBpbmdDb21wb25lbnRQcm9wcyIsImZha2VEeW5hbWljSW1wb3J0IiwibW9kdWxlVG9JbXBvcnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvbXBhcmVOb2RlVHlwZU9mIiwibWF0Y2hpbmdUeXBlT2YiLCIkJHR5cGVvZiIsInNweU1ldGhvZCIsIm1ldGhvZE5hbWUiLCJnZXRTdHViIiwibGFzdFJldHVyblZhbHVlIiwib3JpZ2luYWxNZXRob2QiLCJoYXNPd24iLCJoYXMiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwic3BpZWQiLCJhcmdzIiwiYXBwbHkiLCJyZXN0b3JlIiwiZ2V0TGFzdFJldHVyblZhbHVlIiwic3B5UHJvcGVydHkiLCJwcm9wZXJ0eU5hbWUiLCJoYW5kbGVycyIsIm9yaWdpbmFsVmFsdWUiLCJ3YXNBc3NpZ25lZCIsImhvbGRlciIsImdldFYiLCJnZXQiLCJzZXQiLCJuZXdWYWx1ZSIsImhhbmRsZXJOZXdWYWx1ZSIsInYiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJjb250YWluZXIiLCJjb250YWluZXJGaWJlciIsIl9pbnRlcm5hbFJvb3QiLCJjdXJyZW50IiwiY2hpbGQiLCJ0YWciLCJIb3N0Q29tcG9uZW50IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJzdGF0ZU5vZGUiXSwic291cmNlcyI6WyIuLi9zcmMvVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZ1bmN0aW9uTmFtZSBmcm9tICdmdW5jdGlvbi5wcm90b3R5cGUubmFtZSc7XG5pbXBvcnQgZnJvbUVudHJpZXMgZnJvbSAnb2JqZWN0LmZyb21lbnRyaWVzJztcbmltcG9ydCBoYXMgZnJvbSAnaGFzJztcbmltcG9ydCBjcmVhdGVNb3VudFdyYXBwZXIgZnJvbSAnLi9jcmVhdGVNb3VudFdyYXBwZXInO1xuaW1wb3J0IGNyZWF0ZVJlbmRlcldyYXBwZXIgZnJvbSAnLi9jcmVhdGVSZW5kZXJXcmFwcGVyJztcbmltcG9ydCB3cmFwIGZyb20gJy4vd3JhcFdpdGhTaW1wbGVXcmFwcGVyJztcbmltcG9ydCBSb290RmluZGVyIGZyb20gJy4vUm9vdEZpbmRlcic7XG5pbXBvcnQgeyBIb3N0Q29tcG9uZW50IH0gZnJvbSAnLi90YWdDb2Rlcyc7XG5pbXBvcnQgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5leHBvcnQgeyBjcmVhdGVNb3VudFdyYXBwZXIsIGNyZWF0ZVJlbmRlcldyYXBwZXIsIHdyYXAsIFJvb3RGaW5kZXIgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1hcE5hdGl2ZUV2ZW50TmFtZXMoZXZlbnQpIHtcbiAgY29uc3QgbmF0aXZlVG9SZWFjdEV2ZW50TWFwID0ge1xuICAgIGNvbXBvc2l0aW9uZW5kOiAnY29tcG9zaXRpb25FbmQnLFxuICAgIGNvbXBvc2l0aW9uc3RhcnQ6ICdjb21wb3NpdGlvblN0YXJ0JyxcbiAgICBjb21wb3NpdGlvbnVwZGF0ZTogJ2NvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICBrZXlkb3duOiAna2V5RG93bicsXG4gICAga2V5dXA6ICdrZXlVcCcsXG4gICAga2V5cHJlc3M6ICdrZXlQcmVzcycsXG4gICAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gICAgZGJsY2xpY2s6ICdkb3VibGVDbGljaycsXG4gICAgZG91YmxlY2xpY2s6ICdkb3VibGVDbGljaycsIC8vIGtlcHQgZm9yIGxlZ2FjeS4gVE9ETzogcmVtb3ZlIHdpdGggbmV4dCBtYWpvci5cbiAgICBkcmFnZW5kOiAnZHJhZ0VuZCcsXG4gICAgZHJhZ2VudGVyOiAnZHJhZ0VudGVyJyxcbiAgICBkcmFnZXhpc3Q6ICdkcmFnRXhpdCcsXG4gICAgZHJhZ2xlYXZlOiAnZHJhZ0xlYXZlJyxcbiAgICBkcmFnb3ZlcjogJ2RyYWdPdmVyJyxcbiAgICBkcmFnc3RhcnQ6ICdkcmFnU3RhcnQnLFxuICAgIG1vdXNlZG93bjogJ21vdXNlRG93bicsXG4gICAgbW91c2Vtb3ZlOiAnbW91c2VNb3ZlJyxcbiAgICBtb3VzZW91dDogJ21vdXNlT3V0JyxcbiAgICBtb3VzZW92ZXI6ICdtb3VzZU92ZXInLFxuICAgIG1vdXNldXA6ICdtb3VzZVVwJyxcbiAgICB0b3VjaGNhbmNlbDogJ3RvdWNoQ2FuY2VsJyxcbiAgICB0b3VjaGVuZDogJ3RvdWNoRW5kJyxcbiAgICB0b3VjaG1vdmU6ICd0b3VjaE1vdmUnLFxuICAgIHRvdWNoc3RhcnQ6ICd0b3VjaFN0YXJ0JyxcbiAgICBjYW5wbGF5OiAnY2FuUGxheScsXG4gICAgY2FucGxheXRocm91Z2g6ICdjYW5QbGF5VGhyb3VnaCcsXG4gICAgZHVyYXRpb25jaGFuZ2U6ICdkdXJhdGlvbkNoYW5nZScsXG4gICAgbG9hZGVkZGF0YTogJ2xvYWRlZERhdGEnLFxuICAgIGxvYWRlZG1ldGFkYXRhOiAnbG9hZGVkTWV0YWRhdGEnLFxuICAgIGxvYWRzdGFydDogJ2xvYWRTdGFydCcsXG4gICAgcmF0ZWNoYW5nZTogJ3JhdGVDaGFuZ2UnLFxuICAgIHRpbWV1cGRhdGU6ICd0aW1lVXBkYXRlJyxcbiAgICB2b2x1bWVjaGFuZ2U6ICd2b2x1bWVDaGFuZ2UnLFxuICAgIGJlZm9yZWlucHV0OiAnYmVmb3JlSW5wdXQnLFxuICAgIG1vdXNlZW50ZXI6ICdtb3VzZUVudGVyJyxcbiAgICBtb3VzZWxlYXZlOiAnbW91c2VMZWF2ZScsXG4gICAgdHJhbnNpdGlvbmVuZDogJ3RyYW5zaXRpb25FbmQnLFxuICAgIGFuaW1hdGlvbnN0YXJ0OiAnYW5pbWF0aW9uU3RhcnQnLFxuICAgIGFuaW1hdGlvbml0ZXJhdGlvbjogJ2FuaW1hdGlvbkl0ZXJhdGlvbicsXG4gICAgYW5pbWF0aW9uZW5kOiAnYW5pbWF0aW9uRW5kJyxcbiAgICBwb2ludGVyZG93bjogJ3BvaW50ZXJEb3duJyxcbiAgICBwb2ludGVybW92ZTogJ3BvaW50ZXJNb3ZlJyxcbiAgICBwb2ludGVydXA6ICdwb2ludGVyVXAnLFxuICAgIHBvaW50ZXJjYW5jZWw6ICdwb2ludGVyQ2FuY2VsJyxcbiAgICBnb3Rwb2ludGVyY2FwdHVyZTogJ2dvdFBvaW50ZXJDYXB0dXJlJyxcbiAgICBsb3N0cG9pbnRlcmNhcHR1cmU6ICdsb3N0UG9pbnRlckNhcHR1cmUnLFxuICAgIHBvaW50ZXJlbnRlcjogJ3BvaW50ZXJFbnRlcicsXG4gICAgcG9pbnRlcmxlYXZlOiAncG9pbnRlckxlYXZlJyxcbiAgICBwb2ludGVyb3ZlcjogJ3BvaW50ZXJPdmVyJyxcbiAgICBwb2ludGVyb3V0OiAncG9pbnRlck91dCcsXG4gICAgYXV4Y2xpY2s6ICdhdXhDbGljaycsXG4gIH07XG5cbiAgcmV0dXJuIG5hdGl2ZVRvUmVhY3RFdmVudE1hcFtldmVudF0gfHwgZXZlbnQ7XG59XG5cbi8vICdjbGljaycgPT4gJ29uQ2xpY2snXG4vLyAnbW91c2VFbnRlcicgPT4gJ29uTW91c2VFbnRlcidcbmV4cG9ydCBmdW5jdGlvbiBwcm9wRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IG5hdGl2ZUV2ZW50ID0gbWFwTmF0aXZlRXZlbnROYW1lcyhldmVudCk7XG4gIHJldHVybiBgb24ke25hdGl2ZUV2ZW50WzBdLnRvVXBwZXJDYXNlKCl9JHtuYXRpdmVFdmVudC5zbGljZSgxKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aFNldFN0YXRlQWxsb3dlZChmbikge1xuICAvLyBOT1RFKGxtcik6XG4gIC8vIHRoaXMgaXMgY3VycmVudGx5IGhlcmUgdG8gY2lyY3VtdmVudCBhIFJlYWN0IGJ1ZyB3aGVyZSBgc2V0U3RhdGUoKWAgaXNcbiAgLy8gbm90IGFsbG93ZWQgd2l0aG91dCBnbG9iYWwgYmVpbmcgZGVmaW5lZC5cbiAgbGV0IGNsZWFudXAgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2xlYW51cCA9IHRydWU7XG4gICAgZ2xvYmFsLmRvY3VtZW50ID0ge307XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gZm4oKTtcbiAgaWYgKGNsZWFudXApIHtcbiAgICAvLyBUaGlzIHdvcmtzIGFyb3VuZCBhIGJ1ZyBpbiBub2RlL2plc3QgaW4gdGhhdCBkZXZlbG9wZXJzIGFyZW4ndCBhYmxlIHRvXG4gICAgLy8gZGVsZXRlIHRoaW5ncyBmcm9tIGdsb2JhbCB3aGVuIHJ1bm5pbmcgaW4gYSBub2RlIHZtLlxuICAgIGdsb2JhbC5kb2N1bWVudCA9IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgZ2xvYmFsLmRvY3VtZW50O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREb21BdmFpbGFibGUoZmVhdHVyZSkge1xuICBpZiAoIWdsb2JhbCB8fCAhZ2xvYmFsLmRvY3VtZW50IHx8ICFnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lJ3MgJHtmZWF0dXJlfSBleHBlY3RzIGEgRE9NIGVudmlyb25tZW50IHRvIGJlIGxvYWRlZCwgYnV0IGZvdW5kIG5vbmVgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGxheU5hbWVPZk5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IHsgdHlwZSB9ID0gbm9kZTtcblxuICBpZiAoIXR5cGUpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uTmFtZSh0eXBlKSA6IHR5cGUubmFtZSB8fCB0eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVUeXBlRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICdob3N0JztcbiAgfVxuICBpZiAodHlwZSAmJiB0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICdjbGFzcyc7XG4gIH1cbiAgcmV0dXJuICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4ob2JqKSB7XG4gIGNvbnN0IGl0ZXJhdG9yRm4gPVxuICAgIG9iaiAmJlxuICAgICgodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcgJiZcbiAgICAgIG9ialtTeW1ib2wuaXRlcmF0b3JdKSB8fFxuICAgICAgb2JqWydAQGl0ZXJhdG9yJ10pO1xuXG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNJdGVyYWJsZShvYmopIHtcbiAgcmV0dXJuICEhZ2V0SXRlcmF0b3JGbihvYmopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHwgKHR5cGVvZiBvYmogIT09ICdzdHJpbmcnICYmIGlzSXRlcmFibGUob2JqKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycnMpIHtcbiAgLy8gb3B0aW1pemUgZm9yIHRoZSBtb3N0IGNvbW1vbiBjYXNlXG4gIGlmIChBcnJheS5pc0FycmF5KGFycnMpKSB7XG4gICAgcmV0dXJuIGFycnMucmVkdWNlKFxuICAgICAgKGZsYXRBcnJzLCBpdGVtKSA9PiBmbGF0QXJycy5jb25jYXQoaXNBcnJheUxpa2UoaXRlbSkgPyBmbGF0dGVuKGl0ZW0pIDogaXRlbSksXG4gICAgICBbXSxcbiAgICApO1xuICB9XG5cbiAgLy8gZmFsbGJhY2sgZm9yIGFyYml0cmFyeSBpdGVyYWJsZSBjaGlsZHJlblxuICBsZXQgZmxhdEFycnMgPSBbXTtcblxuICBjb25zdCBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihhcnJzKTtcbiAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoYXJycyk7XG5cbiAgbGV0IHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgd2hpbGUgKCFzdGVwLmRvbmUpIHtcbiAgICBjb25zdCBpdGVtID0gc3RlcC52YWx1ZTtcbiAgICBsZXQgZmxhdEl0ZW07XG5cbiAgICBpZiAoaXNBcnJheUxpa2UoaXRlbSkpIHtcbiAgICAgIGZsYXRJdGVtID0gZmxhdHRlbihpdGVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhdEl0ZW0gPSBpdGVtO1xuICAgIH1cblxuICAgIGZsYXRBcnJzID0gZmxhdEFycnMuY29uY2F0KGZsYXRJdGVtKTtcblxuICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gIH1cblxuICByZXR1cm4gZmxhdEFycnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVLZXlPclVuZGVmaW5lZChrZXkpIHtcbiAgcmV0dXJuIGtleSB8fCAoa2V5ID09PSAnJyA/ICcnIDogdW5kZWZpbmVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRUb1RyZWUoZWwsIHJlY3Vyc2UgPSBlbGVtZW50VG9UcmVlKSB7XG4gIGlmICh0eXBlb2YgcmVjdXJzZSAhPT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgLy8gc3BlY2lhbCBjYXNlIGZvciBiYWNrd2FyZHMgY29tcGF0IGZvciBgLm1hcChlbGVtZW50VG9UcmVlKWBcbiAgICByZWN1cnNlID0gZWxlbWVudFRvVHJlZTtcbiAgfVxuICBpZiAoZWwgPT09IG51bGwgfHwgdHlwZW9mIGVsICE9PSAnb2JqZWN0JyB8fCAhKCd0eXBlJyBpbiBlbCkpIHtcbiAgICByZXR1cm4gZWw7XG4gIH1cbiAgY29uc3QgeyB0eXBlLCBwcm9wcywga2V5LCByZWYgfSA9IGVsO1xuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgbGV0IHJlbmRlcmVkID0gbnVsbDtcbiAgaWYgKGlzQXJyYXlMaWtlKGNoaWxkcmVuKSkge1xuICAgIHJlbmRlcmVkID0gZmxhdHRlbihjaGlsZHJlbikubWFwKCh4KSA9PiByZWN1cnNlKHgpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVuZGVyZWQgPSByZWN1cnNlKGNoaWxkcmVuKTtcbiAgfVxuXG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZVR5cGVGcm9tVHlwZSh0eXBlKTtcblxuICBpZiAobm9kZVR5cGUgPT09ICdob3N0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkge1xuICAgIGlmIChwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlVHlwZSxcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQoa2V5KSxcbiAgICByZWYsXG4gICAgaW5zdGFuY2U6IG51bGwsXG4gICAgcmVuZGVyZWQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcEZpbmQoYXJyYXlsaWtlLCBtYXBwZXIsIGZpbmRlcikge1xuICBsZXQgZm91bmQ7XG4gIGNvbnN0IGlzRm91bmQgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGFycmF5bGlrZSwgKGl0ZW0pID0+IHtcbiAgICBmb3VuZCA9IG1hcHBlcihpdGVtKTtcbiAgICByZXR1cm4gZmluZGVyKGZvdW5kKTtcbiAgfSk7XG4gIHJldHVybiBpc0ZvdW5kID8gZm91bmQgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRWxlbWVudChlbCwgcHJlZGljYXRlKSB7XG4gIGlmIChlbCA9PT0gbnVsbCB8fCB0eXBlb2YgZWwgIT09ICdvYmplY3QnIHx8ICEoJ3R5cGUnIGluIGVsKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHByZWRpY2F0ZShlbCkpIHtcbiAgICByZXR1cm4gZWw7XG4gIH1cbiAgY29uc3QgeyByZW5kZXJlZCB9ID0gZWw7XG4gIGlmIChpc0FycmF5TGlrZShyZW5kZXJlZCkpIHtcbiAgICByZXR1cm4gbWFwRmluZChcbiAgICAgIHJlbmRlcmVkLFxuICAgICAgKHgpID0+IGZpbmRFbGVtZW50KHgsIHByZWRpY2F0ZSksXG4gICAgICAoeCkgPT4gdHlwZW9mIHggIT09ICd1bmRlZmluZWQnLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGZpbmRFbGVtZW50KHJlbmRlcmVkLCBwcmVkaWNhdGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvcHNXaXRoS2V5c0FuZFJlZihub2RlKSB7XG4gIGlmIChub2RlLnJlZiAhPT0gbnVsbCB8fCBub2RlLmtleSAhPT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ub2RlLnByb3BzLFxuICAgICAga2V5OiBub2RlLmtleSxcbiAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbm9kZS5wcm9wcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBvbmVudFN0YWNrKFxuICBoaWVyYXJjaHksXG4gIGdldE5vZGVUeXBlID0gbm9kZVR5cGVGcm9tVHlwZSxcbiAgZ2V0RGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZU9mTm9kZSxcbikge1xuICBjb25zdCB0dXBsZXMgPSBoaWVyYXJjaHlcbiAgICAuZmlsdGVyKChub2RlKSA9PiBub2RlLnR5cGUgIT09IFJvb3RGaW5kZXIpXG4gICAgLm1hcCgoeCkgPT4gW2dldE5vZGVUeXBlKHgudHlwZSksIGdldERpc3BsYXlOYW1lKHgpXSlcbiAgICAuY29uY2F0KFtbJ2NsYXNzJywgJ1dyYXBwZXJDb21wb25lbnQnXV0pO1xuXG4gIHJldHVybiB0dXBsZXNcbiAgICAubWFwKChbLCBuYW1lXSwgaSwgYXJyKSA9PiB7XG4gICAgICBjb25zdCBbLCBjbG9zZXN0Q29tcG9uZW50XSA9IGFyci5zbGljZShpICsgMSkuZmluZCgoW25vZGVUeXBlXSkgPT4gbm9kZVR5cGUgIT09ICdob3N0JykgfHwgW107XG4gICAgICByZXR1cm4gYFxcbiAgICBpbiAke25hbWV9JHtjbG9zZXN0Q29tcG9uZW50ID8gYCAoY3JlYXRlZCBieSAke2Nsb3Nlc3RDb21wb25lbnR9KWAgOiAnJ31gO1xuICAgIH0pXG4gICAgLmpvaW4oJycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2ltdWxhdGVFcnJvcihcbiAgZXJyb3IsXG4gIGNhdGNoaW5nSW5zdGFuY2UsXG4gIHJvb3ROb2RlLCAvLyBUT0RPOiByZW1vdmUgYHJvb3ROb2RlYCBuZXh0IHNlbXZlci1tYWpvclxuICBoaWVyYXJjaHksXG4gIGdldE5vZGVUeXBlID0gbm9kZVR5cGVGcm9tVHlwZSxcbiAgZ2V0RGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZU9mTm9kZSxcbiAgY2F0Y2hpbmdUeXBlID0ge30sXG4pIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjYXRjaGluZ0luc3RhbmNlIHx8IHt9O1xuXG4gIGNvbnN0IHsgY29tcG9uZW50RGlkQ2F0Y2ggfSA9IGluc3RhbmNlO1xuXG4gIGNvbnN0IHsgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIH0gPSBjYXRjaGluZ1R5cGU7XG5cbiAgaWYgKCFjb21wb25lbnREaWRDYXRjaCAmJiAhZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZiAoZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgY29uc3Qgc3RhdGVVcGRhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IuY2FsbChjYXRjaGluZ1R5cGUsIGVycm9yKTtcbiAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgaW5zdGFuY2Uuc2V0U3RhdGUoc3RhdGVVcGRhdGUpO1xuICAgIH0pXG4gIH1cblxuICBpZiAoY29tcG9uZW50RGlkQ2F0Y2gpIHtcbiAgICBjb25zdCBjb21wb25lbnRTdGFjayA9IGdldENvbXBvbmVudFN0YWNrKGhpZXJhcmNoeSwgZ2V0Tm9kZVR5cGUsIGdldERpc3BsYXlOYW1lKTtcbiAgICBjb21wb25lbnREaWRDYXRjaC5jYWxsKGluc3RhbmNlLCBlcnJvciwgeyBjb21wb25lbnRTdGFjayB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dChjb250ZXh0VHlwZXMsIHVubWFza2VkQ29udGV4dCkge1xuICBpZiAoIWNvbnRleHRUeXBlcyB8fCAhdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBmcm9tRW50cmllcyhPYmplY3Qua2V5cyhjb250ZXh0VHlwZXMpLm1hcCgoa2V5KSA9PiBba2V5LCB1bm1hc2tlZENvbnRleHRba2V5XV0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVGcm9tUm9vdEZpbmRlcihpc0N1c3RvbUNvbXBvbmVudCwgdHJlZSwgb3B0aW9ucykge1xuICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50KG9wdGlvbnMud3JhcHBpbmdDb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIHRyZWUucmVuZGVyZWQ7XG4gIH1cbiAgY29uc3Qgcm9vdEZpbmRlciA9IGZpbmRFbGVtZW50KHRyZWUsIChub2RlKSA9PiBub2RlLnR5cGUgPT09IFJvb3RGaW5kZXIpO1xuICBpZiAoIXJvb3RGaW5kZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3cmFwcGluZ0NvbXBvbmVudGAgbXVzdCByZW5kZXIgaXRzIGNoaWxkcmVuIScpO1xuICB9XG4gIHJldHVybiByb290RmluZGVyLnJlbmRlcmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudChjcmVhdGVFbGVtZW50LCBub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgd3JhcHBpbmdDb21wb25lbnQsIHdyYXBwaW5nQ29tcG9uZW50UHJvcHMgfSA9IG9wdGlvbnM7XG4gIGlmICghd3JhcHBpbmdDb21wb25lbnQpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICB3cmFwcGluZ0NvbXBvbmVudCxcbiAgICB3cmFwcGluZ0NvbXBvbmVudFByb3BzLFxuICAgIGNyZWF0ZUVsZW1lbnQoUm9vdEZpbmRlciwgbnVsbCwgbm9kZSksXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXcmFwcGluZ0NvbXBvbmVudE1vdW50UmVuZGVyZXIoeyB0b1RyZWUsIGdldE1vdW50V3JhcHBlckluc3RhbmNlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICBnZXROb2RlKCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRNb3VudFdyYXBwZXJJbnN0YW5jZSgpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlID8gdG9UcmVlKGluc3RhbmNlKS5yZW5kZXJlZCA6IG51bGw7XG4gICAgfSxcbiAgICByZW5kZXIoZWwsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGdldE1vdW50V3JhcHBlckluc3RhbmNlKCk7XG4gICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHdyYXBwaW5nIGNvbXBvbmVudCBtYXkgbm90IGJlIHVwZGF0ZWQgaWYgdGhlIHJvb3QgaXMgdW5tb3VudGVkLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlLnNldFdyYXBwaW5nQ29tcG9uZW50UHJvcHMoZWwucHJvcHMsIGNhbGxiYWNrKTtcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmFrZUR5bmFtaWNJbXBvcnQobW9kdWxlVG9JbXBvcnQpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRlZmF1bHQ6IG1vZHVsZVRvSW1wb3J0IH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZU5vZGVUeXBlT2Yobm9kZSwgbWF0Y2hpbmdUeXBlT2YpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlLiQkdHlwZW9mID09PSBtYXRjaGluZ1R5cGVPZjtcbn1cblxuLy8gVE9ETzogd2hlbiBlbnp5bWUgdjMuMTIuMCBpcyByZXF1aXJlZCwgZGVsZXRlIHRoaXNcbmV4cG9ydCBmdW5jdGlvbiBzcHlNZXRob2QoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIGdldFN0dWIgPSAoKSA9PiB7fSkge1xuICBsZXQgbGFzdFJldHVyblZhbHVlO1xuICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGluc3RhbmNlW21ldGhvZE5hbWVdO1xuICBjb25zdCBoYXNPd24gPSBoYXMoaW5zdGFuY2UsIG1ldGhvZE5hbWUpO1xuICBsZXQgZGVzY3JpcHRvcjtcbiAgaWYgKGhhc093bikge1xuICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluc3RhbmNlLCBtZXRob2ROYW1lKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogIWRlc2NyaXB0b3IgfHwgISFkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgdmFsdWU6XG4gICAgICBnZXRTdHViKG9yaWdpbmFsTWV0aG9kKSB8fFxuICAgICAgZnVuY3Rpb24gc3BpZWQoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbGFzdFJldHVyblZhbHVlID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcmVzdG9yZSgpIHtcbiAgICAgIGlmIChoYXNPd24pIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlW21ldGhvZE5hbWVdID0gb3JpZ2luYWxNZXRob2Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBpbnN0YW5jZVttZXRob2ROYW1lXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldExhc3RSZXR1cm5WYWx1ZSgpIHtcbiAgICAgIHJldHVybiBsYXN0UmV0dXJuVmFsdWU7XG4gICAgfSxcbiAgfTtcbn1cblxuLy8gVE9ETzogd2hlbiBlbnp5bWUgdjMuMTIuMCBpcyByZXF1aXJlZCwgZGVsZXRlIHRoaXNcbmV4cG9ydCBmdW5jdGlvbiBzcHlQcm9wZXJ0eShpbnN0YW5jZSwgcHJvcGVydHlOYW1lLCBoYW5kbGVycyA9IHt9KSB7XG4gIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSBpbnN0YW5jZVtwcm9wZXJ0eU5hbWVdO1xuICBjb25zdCBoYXNPd24gPSBoYXMoaW5zdGFuY2UsIHByb3BlcnR5TmFtZSk7XG4gIGxldCBkZXNjcmlwdG9yO1xuICBpZiAoaGFzT3duKSB7XG4gICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5zdGFuY2UsIHByb3BlcnR5TmFtZSk7XG4gIH1cbiAgbGV0IHdhc0Fzc2lnbmVkID0gZmFsc2U7XG4gIGxldCBob2xkZXIgPSBvcmlnaW5hbFZhbHVlO1xuICBjb25zdCBnZXRWID0gaGFuZGxlcnMuZ2V0XG4gICAgPyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmdldCA/IGRlc2NyaXB0b3IuZ2V0LmNhbGwoaW5zdGFuY2UpIDogaG9sZGVyO1xuICAgICAgICByZXR1cm4gaGFuZGxlcnMuZ2V0LmNhbGwoaW5zdGFuY2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICA6ICgpID0+IGhvbGRlcjtcbiAgY29uc3Qgc2V0ID0gaGFuZGxlcnMuc2V0XG4gICAgPyAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgd2FzQXNzaWduZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBoYW5kbGVyTmV3VmFsdWUgPSBoYW5kbGVycy5zZXQuY2FsbChpbnN0YW5jZSwgaG9sZGVyLCBuZXdWYWx1ZSk7XG4gICAgICAgIGhvbGRlciA9IGhhbmRsZXJOZXdWYWx1ZTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKGluc3RhbmNlLCBob2xkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgOiAodikgPT4ge1xuICAgICAgICB3YXNBc3NpZ25lZCA9IHRydWU7XG4gICAgICAgIGhvbGRlciA9IHY7XG4gICAgICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIHByb3BlcnR5TmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiAhZGVzY3JpcHRvciB8fCAhIWRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICBnZXQ6IGdldFYsXG4gICAgc2V0LFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHJlc3RvcmUoKSB7XG4gICAgICBpZiAoaGFzT3duKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlW3Byb3BlcnR5TmFtZV0gPSBob2xkZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBpbnN0YW5jZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FzQXNzaWduZWQoKSB7XG4gICAgICByZXR1cm4gd2FzQXNzaWduZWQ7XG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLl9pbnRlcm5hbFJvb3QuY3VycmVudDtcblxuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuIl0sIm1hcHBpbmdzIjoi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
//# sourceMappingURL=Utils.js.map